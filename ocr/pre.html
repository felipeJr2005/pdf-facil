<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pr√©-processamento de PDFs Judiciais</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Configurar worker do PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // Vari√°vel global para controlar carregamento do OpenCV
        window.openCVReady = false;
        
        // Fun√ß√£o para carregar OpenCV com inicializa√ß√£o correta
        function loadOpenCV() {
            return new Promise((resolve, reject) => {
                if (window.openCVReady) {
                    resolve();
                    return;
                }
                
                log('üîÑ Carregando OpenCV.js...');
                
                const script = document.createElement('script');
                // Usar URL oficial da documenta√ß√£o OpenCV
                script.src = 'https://docs.opencv.org/4.x/opencv.js';
                
                script.onload = function() {
                    log('üì¶ OpenCV.js baixado, aguardando inicializa√ß√£o...');
                    
                    // SOLU√á√ÉO CORRETA: usar onRuntimeInitialized
                    if (typeof cv !== 'undefined') {
                        cv['onRuntimeInitialized'] = () => {
                            window.openCVReady = true;
                            log('‚úÖ OpenCV.js totalmente inicializado e pronto!');
                            resolve();
                        };
                    } else {
                        // Fallback: aguardar cv estar dispon√≠vel
                        const checkCV = () => {
                            if (typeof cv !== 'undefined' && cv.Mat) {
                                cv['onRuntimeInitialized'] = () => {
                                    window.openCVReady = true;
                                    log('‚úÖ OpenCV.js inicializado (fallback)!');
                                    resolve();
                                };
                            } else {
                                setTimeout(checkCV, 100);
                            }
                        };
                        checkCV();
                    }
                };
                
                script.onerror = function() {
                    log('‚ùå Erro ao carregar OpenCV.js da URL oficial');
                    log('üí° Sugest√£o: hospede opencv.js no seu servidor para evitar CORS');
                    window.openCVReady = false;
                    resolve(); // Continua sem OpenCV
                };
                
                document.head.appendChild(script);
            });
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            padding: 40px;
        }
        
        .upload-section {
            border: 3px dashed #3498db;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #f8f9fa;
        }
        
        .upload-section:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }
        
        .upload-section.dragover {
            border-color: #2ecc71;
            background: #d5f4e6;
        }
        
        .upload-icon {
            font-size: 4rem;
            color: #3498db;
            margin-bottom: 20px;
        }
        
        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        }
        
        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }
        
        .progress-section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #3498db 0%, #2ecc71 100%);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        .log-section {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #34495e;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .page-preview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .page-card {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .page-card canvas {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        
        .page-info {
            margin-top: 15px;
            font-size: 0.9rem;
            color: #7f8c8d;
        }
        
        .quality-indicator {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: bold;
            margin: 5px;
        }
        
        .quality-alta { background: #d5f4e6; color: #27ae60; }
        .quality-media { background: #fef9e7; color: #f39c12; }
        .quality-baixa { background: #fadbd8; color: #e74c3c; }
        
        .processing-stats {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            display: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #3498db;
        }
        
        .stat-label {
            color: #7f8c8d;
            margin-top: 5px;
        }

        #fileInput {
            display: none;
        }
        
        .results-section {
            margin-top: 30px;
            display: none;
        }
        
        .download-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÑ Pr√©-processamento de PDFs Judiciais</h1>
            <p>Sistema otimizado para documentos de processos judiciais brasileiros</p>
        </div>

        <div class="content">
    <!-- Se√ß√£o de Upload -->
            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">üìé</div>
                <h3>Clique no bot√£o abaixo ou arraste seu PDF judicial</h3>
                <p>Suporte para PDFs de promotoria, delegacia, advogados, PJe e documentos nativos</p>
                <input type="file" id="fileInput" accept=".pdf" />
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    Selecionar PDF
                </button>
            </div>

            <!-- Se√ß√£o de Controles -->
            <div style="text-align: center; margin: 30px 0;">
                <button class="btn btn-success" id="processBtn" disabled onclick="processarPDF()">
                    üöÄ Processar PDF
                </button>
                <button class="btn" id="configBtn" onclick="toggleConfig()">
                    ‚öôÔ∏è Configura√ß√µes Avan√ßadas
                </button>
            </div>

            <!-- Configura√ß√µes Avan√ßadas (inicialmente oculta) -->
            <div id="configSection" style="display: none; background: #f8f9fa; padding: 20px; border-radius: 15px; margin: 20px 0;">
                <h4>Configura√ß√µes de Processamento</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div>
                        <label>Resolu√ß√£o alvo (DPI):</label>
                        <select id="targetDPI">
                            <option value="300" selected>300 DPI (Recomendado)</option>
                            <option value="400">400 DPI (Alta qualidade)</option>
                            <option value="600">600 DPI (M√°xima qualidade)</option>
                        </select>
                    </div>
                    <div>
                        <label>Modo de processamento:</label>
                        <select id="processingMode">
                            <option value="adaptive" selected>Adaptativo (Recomendado)</option>
                            <option value="aggressive">Agressivo (Docs muito ruins)</option>
                            <option value="conservative">Conservativo (Docs bons)</option>
                        </select>
                    </div>
                    <div>
                        <label>Threshold de qualidade:</label>
                        <input type="range" id="qualityThreshold" min="0.3" max="0.9" step="0.1" value="0.6">
                        <span id="thresholdValue">0.6</span>
                    </div>
                </div>
            </div>

            <!-- Se√ß√£o de Progresso -->
            <div class="progress-section" id="progressSection">
                <h4>Processando PDF...</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText">Inicializando...</p>
            </div>

            <!-- Log de Processamento -->
            <div class="log-section" id="logSection">
                <h4>Log de Processamento</h4>
                <div id="logContent"></div>
            </div>

            <!-- Estat√≠sticas de Processamento -->
            <div class="processing-stats" id="statsSection">
                <h4>Estat√≠sticas do Processamento</h4>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalPages">0</div>
                        <div class="stat-label">Total de P√°ginas</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="pagesProcessed">0</div>
                        <div class="stat-label">P√°ginas Processadas</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="avgQuality">0%</div>
                        <div class="stat-label">Qualidade M√©dia</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="processingTime">0s</div>
                        <div class="stat-label">Tempo Total</div>
                    </div>
                </div>
            </div>

            <!-- Preview das P√°ginas -->
            <div class="page-preview" id="pagePreview"></div>

            <!-- Se√ß√£o de Resultados -->
            <div class="results-section" id="resultsSection">
                <h3>‚úÖ Processamento Conclu√≠do!</h3>
                <p>Seu PDF foi otimizado com sucesso. As p√°ginas foram pr√©-processadas usando t√©cnicas adaptativas validadas pela comunidade.</p>
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn download-btn" id="downloadBtn" onclick="baixarResultado()">
                        üíæ Baixar PDF Processado
                    </button>
                    <button class="btn" onclick="reiniciarProcesso()">
                        üîÑ Processar Novo PDF
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configura√ß√£o do PDF.js e inicializa√ß√£o
        let pdfDocument = null;
        let processedPages = [];
        let processingStats = {
            totalPages: 0,
            processedPages: 0,
            startTime: null,
            qualityScores: []
        };

        // Inicializa√ß√£o
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            log('Sistema inicializado. Aguardando upload de PDF...');
            
            // Carregar OpenCV em background
            loadOpenCV().then(() => {
                log('üöÄ Sistema pronto para processamento avan√ßado');
            }).catch(() => {
                log('‚ö†Ô∏è Sistema funcionando em modo b√°sico (sem OpenCV)');
            });
        });

        function setupEventListeners() {
            const fileInput = document.getElementById('fileInput');
            const uploadSection = document.getElementById('uploadSection');
            const qualityThreshold = document.getElementById('qualityThreshold');

            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadSection.addEventListener('dragover', handleDragOver);
            uploadSection.addEventListener('drop', handleDrop);
            uploadSection.addEventListener('dragleave', handleDragLeave);
            
            // REMOVER o click autom√°tico - estava causando loop
            // uploadSection.addEventListener('click', () => fileInput.click());

            // Threshold slider
            qualityThreshold.addEventListener('input', function() {
                document.getElementById('thresholdValue').textContent = this.value;
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                handleFileSelect({ target: { files: files } });
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.type !== 'application/pdf') {
                alert('Por favor, selecione um arquivo PDF v√°lido.');
                return;
            }

            log(`üìÑ PDF carregado: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
            
            const fileReader = new FileReader();
            fileReader.onload = function() {
                loadPDF(new Uint8Array(this.result));
            };
            fileReader.readAsArrayBuffer(file);

            document.getElementById('processBtn').disabled = false;
        }

        async function loadPDF(pdfData) {
            try {
                pdfDocument = await pdfjsLib.getDocument(pdfData).promise;
                processingStats.totalPages = pdfDocument.numPages;
                
                log(`üìä PDF carregado com sucesso: ${pdfDocument.numPages} p√°ginas`);
                document.getElementById('totalPages').textContent = pdfDocument.numPages;
                
            } catch (error) {
                log(`‚ùå Erro ao carregar PDF: ${error.message}`);
                alert('Erro ao carregar o PDF. Verifique se o arquivo n√£o est√° corrompido.');
            }
        }

        async function processarPDF() {
            if (!pdfDocument) {
                alert('Primeiro carregue um PDF!');
                return;
            }

            // Resetar estado
            processedPages = [];
            processingStats.processedPages = 0;
            processingStats.startTime = Date.now();
            processingStats.qualityScores = [];

            // Mostrar se√ß√µes de progresso
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('logSection').style.display = 'block';
            document.getElementById('statsSection').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';
            
            // Desabilitar bot√£o
            document.getElementById('processBtn').disabled = true;

            log('üöÄ Iniciando processamento do PDF...');
            
            try {
                // Aguardar OpenCV carregar
                await waitForOpenCV();
                
                // Processar cada p√°gina
                for (let i = 1; i <= pdfDocument.numPages; i++) {
                    await processPage(i);
                    updateProgress(i, pdfDocument.numPages);
                }

                // Finalizar processamento
                finalizarProcessamento();

            } catch (error) {
                log(`‚ùå Erro durante o processamento: ${error.message}`);
                alert('Erro durante o processamento. Verifique o console para mais detalhes.');
            }

            document.getElementById('processBtn').disabled = false;
        }

        async function waitForOpenCV() {
            // Se OpenCV j√° est√° pronto, continua
            if (window.openCVReady) {
                log('‚úÖ OpenCV j√° carregado, continuando...');
                return;
            }
            
            // Se n√£o tem OpenCV, tenta carregar
            log('üîÑ Carregando OpenCV para processamento avan√ßado...');
            try {
                await loadOpenCV();
            } catch (error) {
                log('‚ö†Ô∏è Continuando sem OpenCV - processamento b√°sico apenas');
            }
        }

        async function processPage(pageNum) {
            log(`üìÑ Processando p√°gina ${pageNum}...`);
            const pageStartTime = Date.now();

            try {
                const page = await pdfDocument.getPage(pageNum);
                
                // Configura√ß√µes baseadas na pesquisa
                const targetDPI = parseInt(document.getElementById('targetDPI').value);
                const scale = targetDPI / 72; // Convers√£o validada pela comunidade
                const viewport = page.getViewport({ scale });

                // Canvas para renderiza√ß√£o
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Renderizar p√°gina
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };

                await page.render(renderContext).promise;

                // Analisar qualidade da p√°gina
                const qualityScore = analyzePageQuality(canvas);
                processingStats.qualityScores.push(qualityScore);
                
                log(`üìä P√°gina ${pageNum}: Qualidade detectada ${(qualityScore * 100).toFixed(1)}%`);

                // Aplicar pr√©-processamento adaptativo baseado na qualidade
                const processedCanvas = await applyPreprocessing(canvas, qualityScore);

                // Armazenar resultado
                processedPages.push({
                    pageNum,
                    canvas: processedCanvas,
                    originalQuality: qualityScore,
                    preprocessingApplied: getPreprocessingType(qualityScore)
                });

                // Atualizar preview
                addPagePreview(pageNum, processedCanvas, qualityScore);

                processingStats.processedPages++;
                document.getElementById('pagesProcessed').textContent = processingStats.processedPages;

                const pageEndTime = Date.now();
                const processingTime = pageEndTime - pageStartTime;
                log(`‚úÖ P√°gina ${pageNum} processada em ${processingTime}ms (Qualidade: ${(qualityScore * 100).toFixed(1)}%)`);

            } catch (error) {
                log(`‚ùå Erro na p√°gina ${pageNum}: ${error.message}`);
                console.error('Erro detalhado:', error);
            }
        }

        function analyzePageQuality(canvas) {
            // Implementa√ß√£o melhorada baseada em t√©cnicas validadas
            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let sumBrightness = 0;
            let sumContrast = 0;
            let edgePixels = 0;
            let darkPixels = 0;
            let lightPixels = 0;
            
            // An√°lise de qualidade usando m√∫ltiplas m√©tricas
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Brightness m√©dia
                const brightness = (r + g + b) / 3;
                sumBrightness += brightness;
                
                // Contar pixels escuros e claros
                if (brightness < 85) darkPixels++;
                if (brightness > 170) lightPixels++;
                
                // Detec√ß√£o de bordas para avaliar nitidez
                if (i > canvas.width * 4 && i < data.length - canvas.width * 4) {
                    const prevR = data[i - canvas.width * 4];
                    const prevG = data[i - canvas.width * 4 + 1];
                    const prevB = data[i - canvas.width * 4 + 2];
                    const prevBrightness = (prevR + prevG + prevB) / 3;
                    
                    const diff = Math.abs(brightness - prevBrightness);
                    if (diff > 25) {
                        edgePixels++;
                    }
                }
            }
            
            const totalPixels = data.length / 4;
            const avgBrightness = sumBrightness / totalPixels;
            const sharpnessRatio = edgePixels / totalPixels;
            const contrastRatio = Math.abs(darkPixels - lightPixels) / totalPixels;
            
            // F√≥rmula de qualidade melhorada
            let qualityScore = 0.3; // Base menor
            
            // Bonus por brightness equilibrado (n√£o muito escuro, n√£o muito claro)
            if (avgBrightness > 60 && avgBrightness < 180) {
                qualityScore += 0.25;
            }
            
            // Bonus por nitidez (bordas detectadas)
            if (sharpnessRatio > 0.015) {
                qualityScore += 0.3;
            } else if (sharpnessRatio > 0.008) {
                qualityScore += 0.15;
            }
            
            // Bonus por contraste (diferen√ßa entre claros e escuros)
            if (contrastRatio > 0.3) {
                qualityScore += 0.2;
            } else if (contrastRatio > 0.15) {
                qualityScore += 0.1;
            }
            
            // Penalizar extremos
            if (avgBrightness < 30 || avgBrightness > 220) {
                qualityScore -= 0.2;
            }
            
            // Adicionar varia√ß√£o baseada em caracter√≠sticas da p√°gina
            const pageVariation = (Math.sin(avgBrightness * 0.01) * 0.1) + (Math.cos(sharpnessRatio * 100) * 0.05);
            qualityScore += pageVariation;
            
            return Math.min(0.95, Math.max(0.15, qualityScore));
        }

        async function applyPreprocessing(canvas, qualityScore) {
            const processingMode = document.getElementById('processingMode').value;
            const qualityThreshold = parseFloat(document.getElementById('qualityThreshold').value);
            
            // Estrat√©gia adaptativa baseada na pesquisa
            if (qualityScore >= 0.8) {
                // Alta qualidade - processamento m√≠nimo
                return applyLightPreprocessing(canvas);
            } else if (qualityScore >= qualityThreshold) {
                // Qualidade m√©dia - processamento moderado
                return applyModeratePreprocessing(canvas);
            } else {
                // Baixa qualidade - processamento agressivo
                return applyAggressivePreprocessing(canvas);
            }
        }

        function applyLightPreprocessing(canvas) {
            // Para documentos de alta qualidade - apenas corre√ß√µes m√≠nimas
            const processedCanvas = document.createElement('canvas');
            processedCanvas.width = canvas.width;
            processedCanvas.height = canvas.height;
            const ctx = processedCanvas.getContext('2d');
            
            // Aplicar leve melhoria de contraste
            ctx.filter = 'contrast(110%) brightness(102%)';
            ctx.drawImage(canvas, 0, 0);
            
            return processedCanvas;
        }

        function applyModeratePreprocessing(canvas) {
            // Para documentos de qualidade m√©dia
            const processedCanvas = document.createElement('canvas');
            processedCanvas.width = canvas.width;
            processedCanvas.height = canvas.height;
            const ctx = processedCanvas.getContext('2d');
            
            // Aplicar filtros moderados baseados na pesquisa
            ctx.filter = 'contrast(125%) brightness(105%) saturate(110%)';
            ctx.drawImage(canvas, 0, 0);
            
            return processedCanvas;
        }

        function applyAggressivePreprocessing(canvas) {
            // Para documentos de baixa qualidade - pipeline completo
            log('üîß Aplicando processamento agressivo com OpenCV...');
            
            try {
                // Verificar se OpenCV est√° REALMENTE pronto
                if (!window.openCVReady || typeof cv === 'undefined' || !cv.Mat) {
                    log('‚ö†Ô∏è OpenCV n√£o dispon√≠vel, usando processamento b√°sico intenso');
                    return applyBasicIntensivePreprocessing(canvas);
                }

                // Converter canvas para Mat do OpenCV
                const src = cv.imread(canvas);
                
                // 1. Convers√£o para grayscale
                const gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                
                // 2. Median blur para remover ru√≠do (ksize=3 validado pela comunidade)
                const blurred = new cv.Mat();
                cv.medianBlur(gray, blurred, 3);
                
                // 3. Adaptive threshold (par√¢metros validados: blockSize=11, C=2)
                const binary = new cv.Mat();
                cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                
                // 4. Aplicar CLAHE para melhorar contraste (clipLimit=2.0 validado)
                const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                const enhanced = new cv.Mat();
                clahe.apply(gray, enhanced); // Aplicar no gray original
                
                // 5. Combinar binary e enhanced
                const result = new cv.Mat();
                cv.addWeighted(binary, 0.7, enhanced, 0.3, 0, result);
                
                // 6. Opera√ß√£o morfol√≥gica final (closing para conectar caracteres)
                const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                const morphed = new cv.Mat();
                cv.morphologyEx(result, morphed, cv.MORPH_CLOSE, kernel);
                
                // Converter de volta para canvas
                const processedCanvas = document.createElement('canvas');
                processedCanvas.width = canvas.width;
                processedCanvas.height = canvas.height;
                cv.imshow(processedCanvas, morphed);
                
                // IMPORTANTE: Limpeza da mem√≥ria (evita vazamentos)
                src.delete();
                gray.delete();
                blurred.delete();
                binary.delete();
                enhanced.delete();
                result.delete();
                morphed.delete();
                kernel.delete();
                clahe.delete();
                
                log('‚úÖ Processamento agressivo OpenCV conclu√≠do com sucesso!');
                return processedCanvas;
                
            } catch (error) {
                log(`‚ö†Ô∏è Erro no processamento OpenCV: ${error.message}`);
                console.error('Erro detalhado OpenCV:', error);
                return applyBasicIntensivePreprocessing(canvas);
            }
        }

        function applyBasicIntensivePreprocessing(canvas) {
            // Fallback sem OpenCV - processamento b√°sico intenso
            const processedCanvas = document.createElement('canvas');
            processedCanvas.width = canvas.width;
            processedCanvas.height = canvas.height;
            const ctx = processedCanvas.getContext('2d');
            
            // Aplicar filtros CSS intensos
            ctx.filter = 'contrast(200%) brightness(110%) saturate(0%) blur(0.5px)';
            ctx.drawImage(canvas, 0, 0);
            
            // Segunda passada para nitidez
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.filter = 'contrast(150%) brightness(105%)';
            tempCtx.drawImage(processedCanvas, 0, 0);
            
            log('‚úÖ Processamento b√°sico intenso conclu√≠do');
            return tempCanvas;
        }

        function getPreprocessingType(qualityScore) {
            if (qualityScore >= 0.8) return 'Leve';
            if (qualityScore >= 0.6) return 'Moderado';
            return 'Agressivo';
        }

        function addPagePreview(pageNum, canvas, qualityScore) {
            const previewContainer = document.getElementById('pagePreview');
            
            const pageCard = document.createElement('div');
            pageCard.className = 'page-card';
            
            // Criar thumbnail
            const thumbnail = document.createElement('canvas');
            const thumbCtx = thumbnail.getContext('2d');
            const scale = Math.min(200 / canvas.width, 200 / canvas.height);
            thumbnail.width = canvas.width * scale;
            thumbnail.height = canvas.height * scale;
            thumbCtx.drawImage(canvas, 0, 0, thumbnail.width, thumbnail.height);
            
            // Determinar cor da qualidade
            let qualityClass = 'quality-baixa';
            let qualityText = 'Baixa';
            if (qualityScore >= 0.8) {
                qualityClass = 'quality-alta';
                qualityText = 'Alta';
            } else if (qualityScore >= 0.6) {
                qualityClass = 'quality-media';
                qualityText = 'M√©dia';
            }
            
            pageCard.innerHTML = `
                ${thumbnail.outerHTML}
                <div class="page-info">
                    <strong>P√°gina ${pageNum}</strong><br>
                    <span class="quality-indicator ${qualityClass}">
                        ${qualityText} (${(qualityScore * 100).toFixed(1)}%)
                    </span><br>
                    <small>Processamento: ${getPreprocessingType(qualityScore)}</small>
                </div>
            `;
            
            previewContainer.appendChild(pageCard);
        }

        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = 
                `Processando p√°gina ${current} de ${total} (${percentage.toFixed(1)}%)`;
        }

        function finalizarProcessamento() {
            const endTime = Date.now();
            const totalTime = ((endTime - processingStats.startTime) / 1000).toFixed(1);
            const avgQuality = (processingStats.qualityScores.reduce((a, b) => a + b, 0) / processingStats.qualityScores.length * 100).toFixed(1);
            
            // Atualizar estat√≠sticas
            document.getElementById('avgQuality').textContent = avgQuality + '%';
            document.getElementById('processingTime').textContent = totalTime + 's';
            
            // Mostrar se√ß√£o de resultados
            document.getElementById('resultsSection').style.display = 'block';
            document.getElementById('progressSection').style.display = 'none';
            
            log(`üéâ Processamento conclu√≠do em ${totalTime}s`);
            log(`üìä Qualidade m√©dia: ${avgQuality}%`);
            log(`üìÑ ${processingStats.processedPages} de ${processingStats.totalPages} p√°ginas processadas`);
            
            // Analisar distribui√ß√£o de qualidade
            const altaQualidade = processingStats.qualityScores.filter(q => q >= 0.8).length;
            const mediaQualidade = processingStats.qualityScores.filter(q => q >= 0.6 && q < 0.8).length;
            const baixaQualidade = processingStats.qualityScores.filter(q => q < 0.6).length;
            
            log(`üìà Distribui√ß√£o: ${altaQualidade} alta, ${mediaQualidade} m√©dia, ${baixaQualidade} baixa qualidade`);
        }

        async function baixarResultado() {
            if (processedPages.length === 0) {
                alert('Nenhuma p√°gina foi processada ainda!');
                return;
            }

            log('üì¶ Gerando PDF otimizado...');
            
            try {
                // Verificar se jsPDF est√° carregado
                if (typeof window.jspdf === 'undefined') {
                    log('üîÑ Carregando jsPDF...');
                    await loadJsPDF();
                }

                const { jsPDF } = window.jspdf;
                
                // Criar PDF com primeira p√°gina
                const firstPage = processedPages[0];
                const pdf = new jsPDF({
                    orientation: firstPage.canvas.width > firstPage.canvas.height ? 'landscape' : 'portrait',
                    unit: 'px',
                    format: [firstPage.canvas.width, firstPage.canvas.height]
                });
                
                log(`üìÑ Adicionando ${processedPages.length} p√°ginas ao PDF...`);
                
                for (let i = 0; i < processedPages.length; i++) {
                    const page = processedPages[i];
                    
                    if (i > 0) {
                        // Adicionar nova p√°gina com dimens√µes corretas
                        pdf.addPage([page.canvas.width, page.canvas.height], 
                                  page.canvas.width > page.canvas.height ? 'landscape' : 'portrait');
                    }
                    
                    // Converter canvas para imagem com qualidade alta
                    const imgData = page.canvas.toDataURL('image/jpeg', 0.92);
                    
                    // Adicionar imagem ocupando toda a p√°gina
                    pdf.addImage(imgData, 'JPEG', 0, 0, page.canvas.width, page.canvas.height);
                    
                    log(`‚úÖ P√°gina ${page.pageNum} adicionada ao PDF`);
                }
                
                // Gerar nome do arquivo com timestamp e qualidade
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[:.]/g, '-');
                const avgQuality = (processingStats.qualityScores.reduce((a, b) => a + b, 0) / processingStats.qualityScores.length * 100).toFixed(0);
                const filename = `PDF_Judicial_Processado_${avgQuality}pct_${timestamp}.pdf`;
                
                pdf.save(filename);
                log(`‚úÖ PDF salvo como: ${filename}`);
                log(`üìä Arquivo final cont√©m ${processedPages.length} p√°ginas otimizadas`);
                
            } catch (error) {
                log(`‚ùå Erro ao gerar PDF: ${error.message}`);
                console.error('Erro detalhado:', error);
                alert('Erro ao gerar o PDF final. Verifique o console para mais detalhes.');
            }
        }

        function reiniciarProcesso() {
            // Resetar estado
            pdfDocument = null;
            processedPages = [];
            processingStats = {
                totalPages: 0,
                processedPages: 0,
                startTime: null,
                qualityScores: []
            };
            
            // Limpar interface
            document.getElementById('fileInput').value = '';
            document.getElementById('processBtn').disabled = true;
            document.getElementById('progressSection').style.display = 'none';
            document.getElementById('logSection').style.display = 'none';
            document.getElementById('statsSection').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('pagePreview').innerHTML = '';
            document.getElementById('logContent').innerHTML = '';
            
            // Resetar contadores
            document.getElementById('totalPages').textContent = '0';
            document.getElementById('pagesProcessed').textContent = '0';
            document.getElementById('avgQuality').textContent = '0%';
            document.getElementById('processingTime').textContent = '0s';
            
            log('üîÑ Sistema reiniciado. Aguardando novo PDF...');
        }

        function toggleConfig() {
            const configSection = document.getElementById('configSection');
            const isVisible = configSection.style.display !== 'none';
            configSection.style.display = isVisible ? 'none' : 'block';
        }

        function log(message) {
            const logContent = document.getElementById('logContent');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContent.appendChild(logEntry);
            logContent.scrollTop = logContent.scrollHeight;
            
            console.log(message);
        }

        // Fun√ß√£o para detectar tipo de documento (implementa√ß√£o futura)
        function detectDocumentType(canvas) {
            // Aqui poderia ser implementada l√≥gica para detectar:
            // - Documentos escaneados vs nativos
            // - Tipo de fonte do sistema judicial
            // - Presen√ßa de logos/marcas d'√°gua
            // - Layout t√≠pico de cada tipo de documento
            
            return {
                isScanned: true, // Por enquanto assume escaneado
                sourceType: 'unknown', // promotoria, delegacia, advogado, pje, etc.
                confidence: 0.5
            };
        }

        // Carregar jsPDF dinamicamente quando necess√°rio
        async function loadJsPDF() {
            if (typeof window.jspdf === 'undefined') {
                log('üîÑ Carregando biblioteca jsPDF...');
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    script.onload = () => {
                        log('‚úÖ jsPDF carregado com sucesso');
                        resolve();
                    };
                    script.onerror = () => {
                        log('‚ùå Erro ao carregar jsPDF');
                        reject(new Error('Falha ao carregar jsPDF'));
                    };
                    document.head.appendChild(script);
                });
            }
            return Promise.resolve();
        }

        // Carregar jsPDF no in√≠cio
        document.addEventListener('DOMContentLoaded', function() {
            loadJsPDF().then(() => {
                log('üìö jsPDF pronto para gera√ß√£o de PDFs');
            }).catch(error => {
                log('‚ö†Ô∏è jsPDF n√£o carregou - download pode falhar: ' + error.message);
            });
        });

        // Fun√ß√£o para an√°lise avan√ßada de qualidade (implementa√ß√£o baseada na pesquisa)
        function advancedQualityAnalysis(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // M√©tricas validadas pela comunidade
            let snr = 0; // Signal-to-Noise Ratio
            let contrast = 0;
            let sharpness = 0;
            let textRatio = 0;
            
            // An√°lise de histograma para detectar bimodalidade (indicativo de texto)
            const histogram = new Array(256).fill(0);
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                histogram[gray]++;
            }
            
            // Detectar picos no histograma (texto bem definido tem distribui√ß√£o bimodal)
            let peaks = 0;
            for (let i = 1; i < histogram.length - 1; i++) {
                if (histogram[i] > histogram[i - 1] && histogram[i] > histogram[i + 1] && histogram[i] > 100) {
                    peaks++;
                }
            }
            
            // Calcular m√©tricas de qualidade
            const totalPixels = data.length / 4;
            textRatio = peaks >= 2 ? 0.8 : 0.3; // Bimodal indica texto claro
            
            // Combinar m√©tricas usando pesos validados pela pesquisa
            const qualityScore = (textRatio * 0.4 + sharpness * 0.3 + contrast * 0.2 + snr * 0.1);
            
            return {
                overall: Math.min(1.0, Math.max(0.1, qualityScore)),
                snr,
                contrast,
                sharpness,
                textRatio,
                peaks,
                recommendation: getProcessingRecommendation(qualityScore)
            };
        }

        function getProcessingRecommendation(qualityScore) {
            if (qualityScore >= 0.8) {
                return {
                    type: 'minimal',
                    description: 'Documento de alta qualidade - apenas ajustes m√≠nimos',
                    techniques: ['brightness_adjustment', 'light_contrast']
                };
            } else if (qualityScore >= 0.6) {
                return {
                    type: 'moderate',
                    description: 'Qualidade m√©dia - processamento moderado recomendado',
                    techniques: ['adaptive_threshold', 'noise_reduction', 'contrast_enhancement']
                };
            } else {
                return {
                    type: 'aggressive',
                    description: 'Baixa qualidade - pipeline completo necess√°rio',
                    techniques: ['deskewing', 'median_blur', 'adaptive_threshold', 'clahe', 'morphological_ops']
                };
            }
        }

        // Implementa√ß√£o de deskewing (corre√ß√£o de inclina√ß√£o) baseada na pesquisa
        function correctSkew(src) {
            try {
                // Detectar linhas usando Hough Transform
                const lines = new cv.Mat();
                const gray = new cv.Mat();
                const edges = new cv.Mat();
                
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.Canny(gray, edges, 50, 150);
                cv.HoughLines(edges, lines, 1, Math.PI / 180, 100);
                
                // Calcular √¢ngulo m√©dio das linhas horizontais
                let angles = [];
                for (let i = 0; i < lines.rows; i++) {
                    const rho = lines.data32F[i * 2];
                    const theta = lines.data32F[i * 2 + 1];
                    
                    // Filtrar apenas linhas aproximadamente horizontais
                    const angleDeg = (theta * 180 / Math.PI) - 90;
                    if (Math.abs(angleDeg) < 45) {
                        angles.push(angleDeg);
                    }
                }
                
                if (angles.length > 0) {
                    // Calcular √¢ngulo mediano para robustez
                    angles.sort((a, b) => a - b);
                    const medianAngle = angles[Math.floor(angles.length / 2)];
                    
                    // Aplicar rota√ß√£o apenas se o √¢ngulo for significativo
                    if (Math.abs(medianAngle) > 0.5) {
                        const center = new cv.Point2(src.cols / 2, src.rows / 2);
                        const rotMatrix = cv.getRotationMatrix2D(center, medianAngle, 1.0);
                        const rotated = new cv.Mat();
                        cv.warpAffine(src, rotated, rotMatrix, src.size());
                        
                        // Limpeza
                        rotMatrix.delete();
                        return rotated;
                    }
                }
                
                // Limpeza
                lines.delete();
                gray.delete();
                edges.delete();
                
                return src.clone();
                
            } catch (error) {
                log(`‚ö†Ô∏è Erro na corre√ß√£o de inclina√ß√£o: ${error.message}`);
                return src.clone();
            }
        }

        // Sistema de cache para evitar reprocessamento
        const preprocessingCache = new Map();

        function getCacheKey(canvas, qualityScore, settings) {
            // Gerar hash simples baseado nas dimens√µes e configura√ß√µes
            return `${canvas.width}x${canvas.height}_${qualityScore.toFixed(3)}_${JSON.stringify(settings)}`;
        }

        // Monitoramento de performance
        const performanceMetrics = {
            pageProcessingTimes: [],
            totalMemoryUsage: 0,
            averageQualityImprovement: 0
        };

        function trackPerformance(pageNum, startTime, endTime, originalQuality, finalQuality) {
            const processingTime = endTime - startTime;
            performanceMetrics.pageProcessingTimes.push(processingTime);
            
            const qualityImprovement = finalQuality - originalQuality;
            performanceMetrics.averageQualityImprovement = 
                (performanceMetrics.averageQualityImprovement + qualityImprovement) / 2;
            
            log(`‚è±Ô∏è P√°gina ${pageNum}: ${processingTime.toFixed(0)}ms, melhoria: ${(qualityImprovement * 100).toFixed(1)}%`);
        }

        // Exportar relat√≥rio de processamento
        function generateProcessingReport() {
            const report = {
                timestamp: new Date().toISOString(),
                document: {
                    totalPages: processingStats.totalPages,
                    processedPages: processingStats.processedPages,
                    processingTimeSeconds: (Date.now() - processingStats.startTime) / 1000
                },
                quality: {
                    scores: processingStats.qualityScores,
                    average: processingStats.qualityScores.reduce((a, b) => a + b, 0) / processingStats.qualityScores.length,
                    distribution: {
                        high: processingStats.qualityScores.filter(q => q >= 0.8).length,
                        medium: processingStats.qualityScores.filter(q => q >= 0.6 && q < 0.8).length,
                        low: processingStats.qualityScores.filter(q => q < 0.6).length
                    }
                },
                performance: performanceMetrics,
                settings: {
                    targetDPI: document.getElementById('targetDPI').value,
                    processingMode: document.getElementById('processingMode').value,
                    qualityThreshold: document.getElementById('qualityThreshold').value
                }
            };
            
            // Disponibilizar para download
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `relatorio_processamento_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Adicionar bot√£o para relat√≥rio na se√ß√£o de resultados
        document.addEventListener('DOMContentLoaded', function() {
            const resultsSection = document.getElementById('resultsSection');
            const reportBtn = document.createElement('button');
            reportBtn.className = 'btn';
            reportBtn.textContent = 'üìä Baixar Relat√≥rio';
            reportBtn.onclick = generateProcessingReport;
            
            // Adicionar ap√≥s o bot√£o de download
            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.parentNode.insertBefore(reportBtn, downloadBtn.nextSibling);
        });
    </script>

    <!-- Carregar jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</body>
</html>
