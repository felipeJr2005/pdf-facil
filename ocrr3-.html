<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Avançado - Tesseract</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.min.js"></script>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #f72585;
            --success-color: #06d6a0;
            --warning-color: #f9844a;
            --error-color: #ef4444;
            --gray-100: #f8f9fa;
            --gray-300: #dee2e6;
            --gray-500: #6c757d;
            --gray-700: #495057;
            --gray-900: #212529;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--gray-100);
            color: var(--gray-900);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-body {
            padding: 20px;
        }

        .drop-zone {
            border: 3px dashed var(--gray-300);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--gray-100);
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: var(--primary-color);
            background: rgba(67, 97, 238, 0.05);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--gray-700);
        }

        .upload-subtext {
            color: var(--gray-500);
        }

        .hidden {
            display: none !important;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(67, 97, 238, 0.3);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .settings-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .settings-label {
            font-weight: 600;
            color: var(--gray-700);
        }

        .control-input {
            padding: 12px;
            border: 2px solid var(--gray-300);
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            appearance: none;
            background: var(--gray-300);
        }

        .progress-bar::-webkit-progress-bar {
            background: var(--gray-300);
            border-radius: 6px;
        }

        .progress-bar::-webkit-progress-value {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 6px;
        }

        .progress-text {
            margin-top: 10px;
            text-align: center;
            font-weight: 600;
            color: var(--gray-700);
        }

        .substep-text {
            margin-top: 5px;
            text-align: center;
            font-size: 0.9rem;
            color: var(--gray-500);
            font-style: italic;
        }

        .editor-content {
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            padding: 20px;
            border: 2px solid var(--gray-300);
            border-radius: 8px;
            background: white;
            font-family: 'Courier New', monospace;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        .editor-content:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
        }

        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .processing-message {
            background: white;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .processing-message i {
            color: var(--primary-color);
            margin-bottom: 20px;
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-message.success {
            background: rgba(6, 214, 160, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(6, 214, 160, 0.3);
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .status-message.warning {
            background: rgba(249, 132, 74, 0.1);
            color: var(--warning-color);
            border: 1px solid rgba(249, 132, 74, 0.3);
        }

        .info-block {
            background: var(--gray-100);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .info-line {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            color: var(--gray-700);
        }

        .info-line:last-child {
            margin-bottom: 0;
        }

        .info-line i {
            color: var(--success-color);
            width: 16px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
        }

        .legal-term {
            background-color: rgba(144, 238, 144, 0.3);
            border-bottom: 2px dotted #4CAF50;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .process-number {
            background-color: rgba(173, 216, 230, 0.3);
            border-bottom: 2px dotted #2196F3;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .legal-reference {
            background-color: rgba(255, 182, 193, 0.3);
            border-bottom: 2px dotted #F44336;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .statistics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            background: var(--gray-100);
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .card-body {
                padding: 15px;
            }
            
            .settings-panel {
                grid-template-columns: 1fr;
            }
            
            .statistics-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Upload Area -->
        <div class="card">
            <div class="card-header">
                <h1 class="card-title">
                    <i class="fas fa-eye"></i>
                    OCR Avançado com Tesseract
                </h1>
            </div>
            <div class="card-body">
                <div class="drop-zone" id="dropZone">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <div class="upload-text">Arraste arquivos ou clique para selecionar</div>
                    <div class="upload-subtext">Suporte para JPG, PNG e PDF (máx. 10MB)</div>
                    <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.pdf" style="display: none;">
                </div>
                <div id="fileInfo"></div>
            </div>
        </div>

        <!-- Settings -->
        <div class="card hidden" id="settingsCard">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-cogs"></i>
                    Configurações de OCR
                </h2>
            </div>
            <div class="card-body">
                <div class="settings-panel">
                    <div class="settings-group">
                        <label class="settings-label">Idioma do Texto:</label>
                        <select class="control-input" id="languageSelect">
                            <option value="por">Português</option>
                            <option value="por+jur">Português Jurídico</option>
                            <option value="eng">Inglês</option>
                            <option value="spa">Espanhol</option>
                            <option value="fra">Francês</option>
                            <option value="deu">Alemão</option>
                            <option value="ita">Italiano</option>
                        </select>
                    </div>
                    
                    <div class="settings-group">
                        <label class="settings-label">Qualidade do OCR:</label>
                        <select class="control-input" id="qualitySelect">
                            <option value="fast">Rápido</option>
                            <option value="best" selected>Melhor Qualidade</option>
                            <option value="data_only">Apenas Dados</option>
                        </select>
                    </div>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="enhanceImage" checked>
                    <label for="enhanceImage">Melhorar qualidade da imagem automaticamente</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="highlightTerms">
                    <label for="highlightTerms">Destacar termos jurídicos (apenas português jurídico)</label>
                </div>

                <button class="btn btn-primary" id="startOCR" style="width: 100%; margin-top: 20px;">
                    <i class="fas fa-magic"></i>
                    Iniciar Reconhecimento de Texto
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="card hidden" id="progressCard">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-spinner fa-spin"></i>
                    Processando
                </h2>
            </div>
            <div class="card-body">
                <div class="progress-container">
                    <progress class="progress-bar" id="progressBar" value="0" max="100"></progress>
                    <div class="progress-text" id="progressText">Iniciando...</div>
                    <div class="substep-text" id="substepText"></div>
                </div>
            </div>
        </div>

        <!-- Results -->
        <div class="card hidden" id="resultsCard">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-file-alt"></i>
                    Texto Reconhecido
                </h2>
            </div>
            <div class="card-body">
                <div id="statisticsPanel" class="statistics-panel hidden">
                    <div class="stat-item">
                        <span class="stat-value" id="wordCount">0</span>
                        <span class="stat-label">Palavras</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="charCount">0</span>
                        <span class="stat-label">Caracteres</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="legalTermsCount">0</span>
                        <span class="stat-label">Termos Jurídicos</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="processCount">0</span>
                        <span class="stat-label">Processos</span>
                    </div>
                </div>

                <div id="editorContent" class="editor-content" contenteditable="true" 
                     placeholder="O texto reconhecido aparecerá aqui..."></div>
                
                <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-success" id="copyText">
                        <i class="fas fa-copy"></i>
                        Copiar Texto
                    </button>
                    <button class="btn btn-primary" id="downloadTxt">
                        <i class="fas fa-download"></i>
                        Baixar TXT
                    </button>
                    <button class="btn btn-warning" id="cleanText">
                        <i class="fas fa-broom"></i>
                        Limpar Texto
                    </button>
                </div>
            </div>
        </div>

        <!-- Status Messages -->
        <div id="statusArea"></div>
    </div>

    <!-- Processing Overlay -->
    <div class="processing-overlay hidden" id="processingOverlay">
        <div class="processing-message">
            <i class="fas fa-spinner fa-spin fa-3x"></i>
            <h3 id="overlayTitle">Processando OCR...</h3>
            <p id="overlayMessage">Aguarde enquanto processamos seu arquivo</p>
        </div>
    </div>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.worker.min.js';

        // Global variables
        let currentFile = null;
        let isProcessing = false;

        // Legal terms for highlighting
        const LEGAL_TERMS = [
            'habeas corpus', 'mandado de segurança', 'recurso especial', 'recurso extraordinário',
            'agravo de instrumento', 'apelação', 'embargos', 'liminar', 'tutela antecipada',
            'jurisprudência', 'súmula', 'precedente', 'acórdão', 'sentença', 'decisão',
            'prescrição', 'decadência', 'litispendência', 'coisa julgada', 'mérito',
            'relator', 'revisor', 'ministro', 'desembargador', 'juiz', 'audiência',
            'julgamento', 'ementa', 'autor', 'réu', 'procurador', 'advogado'
        ];

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const settingsCard = document.getElementById('settingsCard');
        const progressCard = document.getElementById('progressCard');
        const resultsCard = document.getElementById('resultsCard');
        const statusArea = document.getElementById('statusArea');
        const processingOverlay = document.getElementById('processingOverlay');

        // Utility functions
        function showStatus(message, type = 'info', duration = 5000) {
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message ${type}`;
            statusDiv.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                ${message}
            `;
            
            statusArea.appendChild(statusDiv);
            
            if (duration > 0) {
                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.parentNode.removeChild(statusDiv);
                    }
                }, duration);
            }
        }

        function updateProgress(value, text, subtext = '') {
            document.getElementById('progressBar').value = value;
            document.getElementById('progressText').textContent = text;
            document.getElementById('substepText').textContent = subtext;
        }

        function showElement(element) {
            if (typeof element === 'string') {
                element = document.getElementById(element);
            }
            if (element) {
                element.classList.remove('hidden');
            }
        }

        function hideElement(element) {
            if (typeof element === 'string') {
                element = document.getElementById(element);
            }
            if (element) {
                element.classList.add('hidden');
            }
        }

        // File validation
        function validateFile(file) {
            const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf'];
            const maxSize = 10 * 1024 * 1024; // 10MB

            if (!validTypes.includes(file.type)) {
                throw new Error('Tipo de arquivo não suportado. Use JPG, PNG ou PDF.');
            }

            if (file.size > maxSize) {
                throw new Error('Arquivo muito grande. Máximo 10MB.');
            }

            return true;
        }

        // Image enhancement for better OCR
        async function enhanceImage(imageData) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageDataObj.data;

                    // Convert to grayscale and enhance contrast
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        // Apply contrast enhancement
                        const enhanced = Math.min(255, Math.max(0, (avg - 128) * 1.5 + 128));
                        data[i] = enhanced;
                        data[i + 1] = enhanced;
                        data[i + 2] = enhanced;
                    }

                    ctx.putImageData(imageDataObj, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };

                img.src = imageData;
            });
        }

        // Advanced text cleaning for legal documents
        function cleanOCRText(text) {
            // Basic cleanup
            text = text.replace(/\r\n/g, '\n');
            text = text.replace(/\t/g, ' ');
            text = text.replace(/ {2,}/g, ' ');

            // Fix common OCR mistakes
            const corrections = {
                '0': 'O', // Zero to letter O in specific contexts
                'lJustiça': 'Justiça',
                'Trjbunal': 'Tribunal',
                'Julgarnento': 'Julgamento',
                'artjgo': 'artigo',
                'paragrato': 'parágrafo',
                'Codigo': 'Código',
                'Lei no': 'Lei nº',
                'açã0': 'ação',
                'ment0': 'mento',
                'çã0': 'ção',
                'nã0': 'não'
            };

            // Apply corrections
            for (const [wrong, correct] of Object.entries(corrections)) {
                const regex = new RegExp(wrong, 'gi');
                text = text.replace(regex, correct);
            }

            // Fix legal references format
            text = text.replace(/lei\s+n[°º]?\s*([0-9.]+)\/([0-9]{4})/gi, 'Lei nº $1/$2');
            text = text.replace(/art\.?\s*(\d+)[,.]\s*([a-zà-ú])/gi, 'art. $1, $2');

            // Format legal headers
            text = text.replace(/ACÓRDÃO/gi, '\n\nACÓRDÃO\n');
            text = text.replace(/RELATÓRIO/gi, '\n\nRELATÓRIO\n');
            text = text.replace(/DECISÃO/gi, '\n\nDECISÃO\n');
            text = text.replace(/SENTENÇA/gi, '\n\nSENTENÇA\n');

            // Remove excessive line breaks
            text = text.replace(/\n{3,}/g, '\n\n');

            return text.trim();
        }

        // Identify and highlight legal terms
        function highlightLegalTerms(text) {
            let highlightedText = text;
            let termsFound = [];
            let processNumbers = [];

            // Highlight legal terms
            LEGAL_TERMS.forEach(term => {
                const regex = new RegExp(`\\b${term}\\b`, 'gi');
                if (regex.test(text)) {
                    termsFound.push(term);
                    highlightedText = highlightedText.replace(regex, `<span class="legal-term">$&</span>`);
                }
            });

            // Highlight process numbers (Brazilian format)
            const processRegex = /\d{7}-\d{2}\.\d{4}\.\d\.\d{2}\.\d{4}/g;
            const processes = text.match(processRegex) || [];
            processes.forEach(process => {
                processNumbers.push(process);
                highlightedText = highlightedText.replace(
                    new RegExp(process.replace(/[-./]/g, '[-./]?'), 'g'),
                    `<span class="process-number">${process}</span>`
                );
            });

            // Update statistics
            updateStatistics(text, termsFound.length, processNumbers.length);

            return highlightedText;
        }

        // Update text statistics
        function updateStatistics(text, legalTermsCount, processCount) {
            const words = text.trim().split(/\s+/).length;
            const chars = text.length;

            document.getElementById('wordCount').textContent = words;
            document.getElementById('charCount').textContent = chars;
            document.getElementById('legalTermsCount').textContent = legalTermsCount;
            document.getElementById('processCount').textContent = processCount;

            showElement('statisticsPanel');
        }

      // Main OCR processing function
        async function processOCR(imageData, language) {
            showElement(processingOverlay);
            document.getElementById('overlayTitle').textContent = 'Processando OCR...';
            document.getElementById('overlayMessage').textContent = 'Analisando imagem e reconhecendo texto';

            try {
                // Enhance image if option is selected
                let processedImage = imageData;
                if (document.getElementById('enhanceImage').checked) {
                    updateProgress(10, 'Melhorando qualidade da imagem...', 'Aplicando filtros de contraste e nitidez');
                    processedImage = await enhanceImage(imageData);
                }

                // Configure Tesseract options
                const quality = document.getElementById('qualitySelect').value;
                let tessOptions = {
                    logger: (m) => {
                        if (m.status === 'recognizing text') {
                            const progress = 20 + (m.progress * 70);
                            updateProgress(progress, 'Reconhecendo texto...', `${Math.round(m.progress * 100)}% concluído`);
                        }
                    }
                };

                // Advanced settings for legal Portuguese
                if (language === 'por+jur') {
                    tessOptions = {
                        ...tessOptions,
                        tessedit_pageseg_mode: '6',
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõöøùúûüýþÿ0123456789.,;:!?()[]{}#$%&*+-=@"\'\\/§º°ª<>|_',
                        preserve_interword_spaces: '1'
                    };
                    language = 'por'; // Use Portuguese as base
                }

                // Quality-specific settings
                switch (quality) {
                    case 'fast':
                        tessOptions.tessedit_pageseg_mode = '1';
                        tessOptions.tessedit_ocr_engine_mode = '1';
                        break;
                    case 'best':
                        tessOptions.tessedit_pageseg_mode = '6';
                        tessOptions.tessedit_ocr_engine_mode = '1';
                        tessOptions.tessedit_char_blacklist = '';
                        break;
                    case 'data_only':
                        tessOptions.tessedit_pageseg_mode = '6';
                        tessOptions.tessedit_create_hocr = '1';
                        break;
                }

                updateProgress(20, 'Iniciando reconhecimento OCR...', 'Configurando Tesseract');

                // Perform OCR
                const result = await Tesseract.recognize(processedImage, language, tessOptions);
                
                updateProgress(90, 'Processando texto reconhecido...', 'Aplicando correções e formatação');

                // Clean and process the text
                let cleanedText = cleanOCRText(result.data.text);
                
                // Apply highlighting if enabled and using legal Portuguese
                if (document.getElementById('highlightTerms').checked && document.getElementById('languageSelect').value === 'por+jur') {
                    cleanedText = highlightLegalTerms(cleanedText);
                    document.getElementById('editorContent').innerHTML = cleanedText;
                } else {
                    document.getElementById('editorContent').textContent = cleanedText;
                    updateStatistics(cleanedText, 0, 0);
                }

                updateProgress(100, 'Concluído!', 'Texto reconhecido com sucesso');

                // Show results
                hideElement(progressCard);
                hideElement(processingOverlay);
                showElement(resultsCard);

                showStatus('Texto reconhecido com sucesso!', 'success');

                return cleanedText;

            } catch (error) {
                console.error('Erro no OCR:', error);
                hideElement(processingOverlay);
                hideElement(progressCard);
                showStatus(`Erro no reconhecimento: ${error.message}`, 'error');
                throw error;
            }
        }

        // Enhanced OCR with multiple attempts for better accuracy
        async function processOCRWithRetry(imageData, language, maxRetries = 2) {
            let bestResult = null;
            let bestConfidence = 0;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    updateProgress(
                        (attempt - 1) * (90 / maxRetries), 
                        `Tentativa ${attempt} de ${maxRetries}...`, 
                        'Processando com diferentes configurações'
                    );

                    const result = await Tesseract.recognize(imageData, language, {
                        logger: (m) => {
                            if (m.status === 'recognizing text') {
                                const baseProgress = (attempt - 1) * (90 / maxRetries);
                                const currentProgress = baseProgress + (m.progress * (90 / maxRetries));
                                updateProgress(currentProgress, `Tentativa ${attempt}: Reconhecendo...`, `${Math.round(m.progress * 100)}%`);
                            }
                        },
                        tessedit_pageseg_mode: attempt === 1 ? '6' : '1',
                        tessedit_ocr_engine_mode: attempt === 1 ? '1' : '2'
                    });

                    const confidence = result.data.confidence;
                    if (confidence > bestConfidence) {
                        bestConfidence = confidence;
                        bestResult = result;
                    }

                    // If confidence is high enough, stop trying
                    if (confidence > 85) {
                        break;
                    }

                } catch (error) {
                    console.warn(`Tentativa ${attempt} falhou:`, error);
                    if (attempt === maxRetries) {
                        throw error;
                    }
                }
            }

            return bestResult || { data: { text: '', confidence: 0 } };
        }

        // Process PDF files with enhanced error handling
        async function processPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const numPages = pdf.numPages;

            let allText = '';
            let successfulPages = 0;
            let failedPages = [];

            updateProgress(5, 'Carregando PDF...', `${numPages} páginas detectadas`);

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                try {
                    updateProgress(
                        5 + ((pageNum - 1) / numPages) * 85,
                        `Processando página ${pageNum} de ${numPages}`,
                        'Extraindo conteúdo da página PDF'
                    );

                    const page = await pdf.getPage(pageNum);
                    const scale = 2.0; // Higher scale for better quality
                    const viewport = page.getViewport({ scale });

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    const imageData = canvas.toDataURL('image/png');
                    const language = document.getElementById('languageSelect').value;
                    
                    // Process individual page with retry mechanism
                    const result = await processOCRWithRetry(imageData, language);
                    const pageText = cleanOCRText(result.data.text);
                    
                    if (pageText.trim()) {
                        allText += `\n\n--- Página ${pageNum} ---\n\n${pageText}`;
                        successfulPages++;
                    } else {
                        failedPages.push(pageNum);
                        allText += `\n\n--- Página ${pageNum} (sem texto detectado) ---\n\n`;
                    }

                } catch (error) {
                    console.error(`Erro na página ${pageNum}:`, error);
                    failedPages.push(pageNum);
                    allText += `\n\n--- Página ${pageNum} (erro no processamento) ---\n\n`;
                }
            }

            // Update final results
            updateProgress(90, 'Finalizando processamento...', 'Aplicando formatação final');

            const finalText = allText.trim();
            
            // Apply highlighting if enabled
            if (document.getElementById('highlightTerms').checked && document.getElementById('languageSelect').value === 'por+jur') {
                const highlightedText = highlightLegalTerms(finalText);
                document.getElementById('editorContent').innerHTML = highlightedText;
            } else {
                document.getElementById('editorContent').textContent = finalText;
                updateStatistics(finalText, 0, 0);
            }

            updateProgress(100, 'PDF processado!', `${successfulPages}/${numPages} páginas processadas com sucesso`);

            // Show summary
            if (failedPages.length > 0) {
                showStatus(
                    `PDF processado! ${successfulPages} páginas com sucesso. ${failedPages.length} páginas falharam: ${failedPages.join(', ')}`, 
                    'warning'
                );
            } else {
                showStatus(`PDF processado com sucesso! Todas as ${numPages} páginas foram processadas.`, 'success');
            }

            hideElement(progressCard);
            hideElement(processingOverlay);
            showElement(resultsCard);

            return finalText;
        }

        // Batch processing for multiple images
        async function processBatchImages(files) {
            let allResults = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    updateProgress(
                        (i / files.length) * 90,
                        `Processando arquivo ${i + 1} de ${files.length}`,
                        `Arquivo: ${file.name}`
                    );

                    const reader = new FileReader();
                    const imageData = await new Promise((resolve) => {
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });

                    const language = document.getElementById('languageSelect').value;
                    const result = await processOCRWithRetry(imageData, language);
                    const cleanedText = cleanOCRText(result.data.text);

                    allResults.push({
                        filename: file.name,
                        text: cleanedText,
                        confidence: result.data.confidence
                    });

                } catch (error) {
                    console.error(`Erro processando ${file.name}:`, error);
                    allResults.push({
                        filename: file.name,
                        text: `Erro no processamento: ${error.message}`,
                        confidence: 0
                    });
                }
            }

            // Combine all results
            const combinedText = allResults.map(result => 
                `--- ${result.filename} (Confiança: ${Math.round(result.confidence)}%) ---\n\n${result.text}`
            ).join('\n\n');

            updateProgress(100, 'Processamento em lote concluído!', `${allResults.length} arquivos processados`);

            document.getElementById('editorContent').textContent = combinedText;
            updateStatistics(combinedText, 0, 0);

            hideElement(progressCard);
            hideElement(processingOverlay);
            showElement(resultsCard);

            return combinedText;
        }

        // Advanced text post-processing with AI-like corrections
        function advancedTextCorrection(text) {
            // Dictionary of common legal terms and their corrections
            const legalCorrections = {
                // Common OCR mistakes in legal documents
                'Supremo Trihunal': 'Supremo Tribunal',
                'Superior Trihunal': 'Superior Tribunal',
                'Trihunal de Justica': 'Tribunal de Justiça',
                'Ministerio Puhlico': 'Ministério Público',
                'Defensoria Puhlica': 'Defensoria Pública',
                'habeas corpus': 'habeas corpus',
                'mandado de seguranca': 'mandado de segurança',
                'recurso especial': 'recurso especial',
                'recurso extraordinario': 'recurso extraordinário',
                'agravo de instrumento': 'agravo de instrumento',
                'açao civil publica': 'ação civil pública',
                'açao de indenizacao': 'ação de indenização',
                'açao de cobranca': 'ação de cobrança',
                'execucao fiscal': 'execução fiscal',
                'embargos a execucao': 'embargos à execução',
                'embargos de declaracao': 'embargos de declaração',
                'apelacao civel': 'apelação cível',
                'apelacao criminal': 'apelação criminal',
                'agravo regimental': 'agravo regimental',
                'agravo interno': 'agravo interno',
                'suspensao de seguranca': 'suspensão de segurança',
                'suspensao de liminar': 'suspensão de liminar',
                'medida cautelar': 'medida cautelar',
                'tutela antecipada': 'tutela antecipada',
                'tutela provisoria': 'tutela provisória',
                'liminar': 'liminar',
                'jurisprudencia': 'jurisprudência',
                'sumula': 'súmula',
                'precedente': 'precedente',
                'acordao': 'acórdão',
                'sentenca': 'sentença',
                'decisao': 'decisão',
                'despacho': 'despacho',
                'prescricao': 'prescrição',
                'decadencia': 'decadência',
                'litispendencia': 'litispendência',
                'coisa julgada': 'coisa julgada',
                'merito': 'mérito',
                'processo': 'processo',
                'procedimento': 'procedimento',
                'petição': 'petição',
                'peticao': 'petição',
                'contestacao': 'contestação',
                'replica': 'tríplica',
                'treplicaa': 'tríplica',
                'impugnacao': 'impugnação',
                'recurso': 'recurso',
                'contra-razoes': 'contra-razões',
                'razoes': 'razões',
                'memoriais': 'memoriais',
                'alegacoes': 'alegações',
                'alegacoes finais': 'alegações finais',
                'instrucao': 'instrução',
                'audiencia': 'audiência',
                'julgamento': 'julgamento',
                'deliberacao': 'deliberação',
                'votacao': 'votação',
                'ementa': 'ementa',
                'relatorio': 'relatório',
                'voto': 'voto',
                'declaracao': 'declaração'
            };

            // Apply legal corrections
            let correctedText = text;
            Object.entries(legalCorrections).forEach(([wrong, correct]) => {
                const regex = new RegExp(wrong, 'gi');
                correctedText = correctedText.replace(regex, correct);
            });

            // Fix common number/letter confusions
            correctedText = correctedText.replace(/(?<!\d)0(?=\s+[a-záàâãéèêíïóôõöúçñ])/g, 'O'); // 0 before words -> O
            correctedText = correctedText.replace(/(?<=^|\s)1(?=\s*[Jj]ustice|[Jj]uiz|[Jj]ulg)/g, 'J'); // 1 before judge-related words -> J
            correctedText = correctedText.replace(/(?<=^|\s)l(?=\s*[Jj]ustice|[Jj]uiz|[Jj]ulg)/g, 'J'); // l before judge-related words -> J

            // Fix date formats
            correctedText = correctedText.replace(/(\d{1,2})\s*de\s+([a-z]+)\s+de\s+(\d{4})/gi, '$1 de $2 de $3');
            correctedText = correctedText.replace(/(\d{1,2})\/(\d{1,2})\/(\d{4})/g, '$1/$2/$3');

            // Fix currency formats
            correctedText = correctedText.replace(/R\$\s*(\d+)[\.,](\d{3})[\.,](\d{2})/g, 'R$ $1.$2,$3');
            correctedText = correctedText.replace(/R\$\s*(\d+)[\.,](\d{2})(?!\d)/g, 'R$ $1,$2');

            // Fix legal citations
            correctedText = correctedText.replace(/art\.?\s*(\d+)[°º]*[,.\s]*([a-zà-ú§°º\d\s]*)/gi, (match, artNum, rest) => {
                return `art. ${artNum}${rest ? ', ' + rest.trim() : ''}`;
            });

            // Fix law references
            correctedText = correctedText.replace(/(lei|decreto|portaria|resolução)\s+n[°º]?\s*([0-9.]+)\/(\d{4})/gi, '$1 nº $2/$3');

            // Fix paragraph references
            correctedText = correctedText.replace(/§\s*(\d+)[°º]*/g, '§ $1º');

            // Fix common spacing issues
            correctedText = correctedText.replace(/\s+/g, ' '); // Multiple spaces to single
            correctedText = correctedText.replace(/\n\s*\n\s*\n+/g, '\n\n'); // Multiple line breaks to double
            correctedText = correctedText.replace(/([.!?])\s*\n\s*([A-ZÁÀÂÃÉÈÊÍÏÓÔÕÖÚÇÑ])/g, '$1\n\n$2'); // Add double break after sentences

            return correctedText.trim();
        }

        // Export functionality with multiple formats
        function setupAdvancedExport() {
            // Export as formatted HTML
            function exportAsHTML() {
                const editor = document.getElementById('editorContent');
                const content = editor.innerHTML || editor.textContent;
                
                const htmlContent = `
                <!DOCTYPE html>
                <html lang="pt-BR">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Texto OCR - ${new Date().toLocaleDateString()}</title>
                    <style>
                        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
                        .legal-term { background-color: rgba(144, 238, 144, 0.3); border-bottom: 2px dotted #4CAF50; }
                        .process-number { background-color: rgba(173, 216, 230, 0.3); border-bottom: 2px dotted #2196F3; font-weight: bold; }
                        .legal-reference { background-color: rgba(255, 182, 193, 0.3); border-bottom: 2px dotted #F44336; font-weight: bold; }
                        h1 { color: #333; border-bottom: 2px solid #4361ee; padding-bottom: 10px; }
                    </style>
                </head>
                <body>
                    <h1>Texto Reconhecido por OCR</h1>
                    <p><strong>Data:</strong> ${new Date().toLocaleString()}</p>
                    <hr>
                    <div>${content}</div>
                </body>
                </html>`;

                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `texto_ocr_${new Date().getTime()}.html`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Arquivo HTML exportado com sucesso!', 'success');
            }

            // Export as JSON with metadata
            function exportAsJSON() {
                const editor = document.getElementById('editorContent');
                const text = editor.textContent || editor.innerText;
                
                const data = {
                    timestamp: new Date().toISOString(),
                    language: document.getElementById('languageSelect').value,
                    quality: document.getElementById('qualitySelect').value,
                    statistics: {
                        words: document.getElementById('wordCount').textContent,
                        characters: document.getElementById('charCount').textContent,
                        legalTerms: document.getElementById('legalTermsCount').textContent,
                        processes: document.getElementById('processCount').textContent
                    },
                    content: text,
                    htmlContent: editor.innerHTML
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dados_ocr_${new Date().getTime()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Dados exportados em JSON com sucesso!', 'success');
            }

            // Add export buttons
            const exportButtons = `
                <button class="btn btn-primary" onclick="exportAsHTML()">
                    <i class="fas fa-code"></i>
                    Exportar HTML
                </button>
                <button class="btn btn-warning" onclick="exportAsJSON()">
                    <i class="fas fa-database"></i>
                    Exportar JSON
                </button>
            `;

            // Make functions global for onclick handlers
            window.exportAsHTML = exportAsHTML;
            window.exportAsJSON = exportAsJSON;

            return exportButtons;
        }

        // Initialize advanced features
        function initAdvancedFeatures() {
            // Add export buttons to results card
            const resultsCard = document.getElementById('resultsCard');
            if (resultsCard) {
                const buttonContainer = resultsCard.querySelector('.card-body > div:last-child');
                if (buttonContainer) {
                    buttonContainer.innerHTML += setupAdvancedExport();
                }
            }

            // Add keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 's':
                            e.preventDefault();
                            document.getElementById('downloadTxt').click();
                            break;
                        case 'k':
                            e.preventDefault();
                            document.getElementById('copyText').click();
                            break;
                        case 'n':
                            e.preventDefault();
                            document.getElementById('cleanText').click();
                            break;
                        case 'e':
                            e.preventDefault();
                            if (typeof exportAsHTML === 'function') exportAsHTML();
                            break;
                        case 'j':
                            e.preventDefault();
                            if (typeof exportAsJSON === 'function') exportAsJSON();
                            break;
                    }
                }
            });

            // Add tooltips for better UX
            addTooltips();

            // Initialize auto-save functionality
            setupAutoSave();

            // Setup confidence threshold alerts
            setupConfidenceAlerts();

            showStatus('Funcionalidades avançadas carregadas! Use Ctrl+S (salvar), Ctrl+K (copiar), Ctrl+N (limpar), Ctrl+E (HTML), Ctrl+J (JSON)', 'success');
        }

        // Add helpful tooltips
        function addTooltips() {
            const tooltips = {
                'enhanceImage': 'Aplica filtros de contraste e nitidez para melhorar a precisão do OCR',
                'highlightTerms': 'Destaca automaticamente termos jurídicos, números de processo e referências legais',
                'languageSelect': 'Português Jurídico oferece configurações otimizadas para documentos legais',
                'qualitySelect': 'Melhor Qualidade demora mais mas oferece maior precisão',
                'startOCR': 'Inicia o processamento OCR com as configurações selecionadas'
            };

            Object.entries(tooltips).forEach(([id, text]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.title = text;
                    element.setAttribute('data-tooltip', text);
                }
            });
        }

        // Auto-save functionality
        function setupAutoSave() {
            let autoSaveInterval;
            const AUTOSAVE_DELAY = 30000; // 30 seconds

            function startAutoSave() {
                clearInterval(autoSaveInterval);
                autoSaveInterval = setInterval(() => {
                    const editor = document.getElementById('editorContent');
                    const content = editor.textContent || editor.innerText;
                    
                    if (content.trim()) {
                        localStorage.setItem('ocr_autosave', JSON.stringify({
                            content: content,
                            timestamp: new Date().toISOString(),
                            language: document.getElementById('languageSelect').value
                        }));
                        
                        // Show subtle auto-save indicator
                        showAutoSaveIndicator();
                    }
                }, AUTOSAVE_DELAY);
            }

            function showAutoSaveIndicator() {
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(6, 214, 160, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 0.8rem;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                indicator.innerHTML = '<i class="fas fa-save"></i> Auto-salvo';
                document.body.appendChild(indicator);

                // Animate in
                setTimeout(() => indicator.style.opacity = '1', 100);
                
                // Animate out and remove
                setTimeout(() => {
                    indicator.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(indicator), 300);
                }, 2000);
            }

            function loadAutoSave() {
                const saved = localStorage.getItem('ocr_autosave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        const timeDiff = new Date() - new Date(data.timestamp);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        
                        if (hoursDiff < 24) { // Only restore if less than 24 hours old
                            if (confirm(`Encontrado texto auto-salvo de ${new Date(data.timestamp).toLocaleString()}. Deseja restaurar?`)) {
                                document.getElementById('editorContent').textContent = data.content;
                                document.getElementById('languageSelect').value = data.language || 'por';
                                showElement('resultsCard');
                                showStatus('Texto auto-salvo restaurado com sucesso!', 'success');
                            }
                        }
                    } catch (error) {
                        console.error('Erro ao carregar auto-save:', error);
                    }
                }
            }

            // Start auto-save when editor has content
            document.addEventListener('DOMContentLoaded', () => {
                loadAutoSave();
                
                const editor = document.getElementById('editorContent');
                if (editor) {
                    editor.addEventListener('input', () => {
                        if (editor.textContent.trim()) {
                            startAutoSave();
                        }
                    });
                }
            });
        }

        // Confidence threshold alerts
        function setupConfidenceAlerts() {
            window.checkOCRConfidence = function(confidence) {
                if (confidence < 60) {
                    showStatus(
                        `Baixa confiança no reconhecimento (${Math.round(confidence)}%). Considere melhorar a qualidade da imagem ou usar configurações diferentes.`,
                        'warning',
                        8000
                    );
                } else if (confidence < 80) {
                    showStatus(
                        `Confiança moderada (${Math.round(confidence)}%). Revise o texto para possíveis erros.`,
                        'warning',
                        5000
                    );
                } else {
                    showStatus(
                        `Alta confiança no reconhecimento (${Math.round(confidence)}%)!`,
                        'success',
                        3000
                    );
                }
            };
        }

        // Advanced image preprocessing with multiple filters
        async function advancedImagePreprocessing(imageData) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageDataObj.data;

                    // Apply multiple enhancement filters
                    applyGrayscaleFilter(data);
                    applyContrastEnhancement(data, 1.5);
                    applyNoiseReduction(data, canvas.width, canvas.height);
                    applySharpening(data, canvas.width, canvas.height);
                    applyBinarization(data, calculateOtsuThreshold(data));

                    ctx.putImageData(imageDataObj, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };

                img.src = imageData;
            });
        }

        // Individual image filter functions
        function applyGrayscaleFilter(data) {
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
        }

        function applyContrastEnhancement(data, factor) {
            const intercept = 128 * (1 - factor);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] * factor + intercept));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * factor + intercept));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * factor + intercept));
            }
        }

        function applyNoiseReduction(data, width, height) {
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    let sum = 0;
                    let count = 0;
                    
                    // 3x3 median filter
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nidx = ((y + dy) * width + (x + dx)) * 4;
                            sum += tempData[nidx];
                            count++;
                        }
                    }
                    
                    const avg = sum / count;
                    data[idx] = data[idx + 1] = data[idx + 2] = avg;
                }
            }
        }

        function applySharpening(data, width, height) {
            const tempData = new Uint8ClampedArray(data);
            const kernel = [-1, -1, -1, -1, 9, -1, -1, -1, -1];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    let sum = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const kidx = ((y + ky) * width + (x + kx)) * 4;
                            const kernelIdx = (ky + 1) * 3 + (kx + 1);
                            sum += tempData[kidx] * kernel[kernelIdx];
                        }
                    }
                    
                    const result = Math.min(255, Math.max(0, sum));
                    data[idx] = data[idx + 1] = data[idx + 2] = result;
                }
            }
        }

        function calculateOtsuThreshold(data) {
            const histogram = new Array(256).fill(0);
            const total = data.length / 4;
            
            // Build histogram
            for (let i = 0; i < data.length; i += 4) {
                histogram[Math.round(data[i])]++;
            }
            
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }
            
            let sumB = 0;
            let wB = 0;
            let wF = 0;
            let varMax = 0;
            let threshold = 0;
            
            for (let i = 0; i < 256; i++) {
                wB += histogram[i];
                if (wB === 0) continue;
                
                wF = total - wB;
                if (wF === 0) break;
                
                sumB += i * histogram[i];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);
                
                if (varBetween > varMax) {
                    varMax = varBetween;
                    threshold = i;
                }
            }
            
            return threshold;
        }

        function applyBinarization(data, threshold) {
            for (let i = 0; i < data.length; i += 4) {
                const value = data[i] > threshold ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = value;
            }
        }

        // Performance monitoring
        function setupPerformanceMonitoring() {
            const performanceData = {
                startTime: null,
                endTime: null,
                filesProcessed: 0,
                totalCharacters: 0,
                averageConfidence: 0
            };

            window.startPerformanceTracking = function() {
                performanceData.startTime = performance.now();
            };

            window.endPerformanceTracking = function(confidence, characterCount) {
                performanceData.endTime = performance.now();
                performanceData.filesProcessed++;
                performanceData.totalCharacters += characterCount;
                performanceData.averageConfidence = 
                    (performanceData.averageConfidence * (performanceData.filesProcessed - 1) + confidence) / performanceData.filesProcessed;

                const processingTime = (performanceData.endTime - performanceData.startTime) / 1000;
                const charactersPerSecond = characterCount / processingTime;

                console.log(`Performance Stats:
                    - Tempo de processamento: ${processingTime.toFixed(2)}s
                    - Caracteres por segundo: ${charactersPerSecond.toFixed(2)}
                    - Confiança média: ${performanceData.averageConfidence.toFixed(1)}%
                    - Total de arquivos: ${performanceData.filesProcessed}
                    - Total de caracteres: ${performanceData.totalCharacters.toLocaleString()}`);

                // Show performance alert if processing is slow
                if (charactersPerSecond < 50) {
                    showStatus('Processamento lento detectado. Considere usar qualidade "Rápido" para arquivos grandes.', 'warning', 6000);
                }
            };
        }

        // Enhanced error handling and recovery
        function setupErrorRecovery() {
            window.addEventListener('error', (event) => {
                console.error('Erro global capturado:', event.error);
                
                // Try to recover from common errors
                if (event.error.message.includes('Tesseract')) {
                    showStatus('Erro no Tesseract detectado. Tentando reinicializar...', 'warning');
                    
                    // Attempt to reload Tesseract
                    setTimeout(() => {
                        location.reload();
                    }, 3000);
                } else if (event.error.message.includes('memory') || event.error.message.includes('Memory')) {
                    showStatus('Erro de memória detectado. Considere processar arquivos menores ou recarregar a página.', 'error', 10000);
                }
            });

            // Handle unhandled promise rejections
            window.addEventListener('unhandledrejection', (event) => {
                console.error('Promise rejeitada:', event.reason);
                showStatus('Erro inesperado no processamento. Verifique o console para detalhes.', 'error', 5000);
                event.preventDefault();
            });
        }

        // Language detection helper
        async function detectLanguage(text) {
            const languagePatterns = {
                por: /\b(que|com|para|uma|dos|pela|mais|como|seu|tem|foi|muito|pode|são|entre|quando|ainda|pelo|sobre|onde|sendo|após|durante|através|portanto|contudo|entretanto)\b/gi,
                eng: /\b(the|and|for|are|but|not|you|all|can|had|her|was|one|our|out|day|get|has|him|his|how|its|may|new|now|old|see|two|way|who|boy|did|man|men|too|any|car|each|end|even|here|off|put|say|she|try|use)\b/gi,
                spa: /\b(que|con|para|una|por|más|como|sus|fue|muy|puede|son|entre|cuando|aún|sobre|donde|siendo|después|durante|través|por tanto|sin embargo)\b/gi,
                fra: /\b(que|avec|pour|une|par|plus|comme|ses|était|très|peut|sont|entre|quand|encore|sur|où|étant|après|pendant|à travers|par conséquent|cependant)\b/gi
            };

            let bestMatch = 'por';
            let maxMatches = 0;

            Object.entries(languagePatterns).forEach(([lang, pattern]) => {
                const matches = (text.match(pattern) || []).length;
                if (matches > maxMatches) {
                    maxMatches = matches;
                    bestMatch = lang;
                }
            });

            return bestMatch;
        }

        // Complete event listener setup
        function setupEventListeners() {
            // File handling
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.add('drag-over');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.remove('drag-over');
                });
            });

            dropZone.addEventListener('drop', (e) => {
                const files = Array.from(e.dataTransfer.files);
                if (files.length === 1) {
                    handleFile(files[0]);
                } else if (files.length > 1) {
                    // Handle multiple files
                    handleMultipleFiles(files);
                }
            });

            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 1) {
                    handleFile(files[0]);
                } else if (files.length > 1) {
                    handleMultipleFiles(files);
                }
            });

            // Start OCR button
            document.getElementById('startOCR').addEventListener('click', async () => {
                if (!currentFile || isProcessing) return;

                isProcessing = true;
                showElement(progressCard);
                hideElement(resultsCard);

                window.startPerformanceTracking();

                try {
                    if (Array.isArray(currentFile)) {
                        // Multiple files
                        await processBatchImages(currentFile);
                    } else if (currentFile.type === 'application/pdf') {
                        await processPDF(currentFile);
                    } else {
                        // Single image file
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            const language = document.getElementById('languageSelect').value;
                            await processOCR(e.target.result, language);
                        };
                        reader.readAsDataURL(currentFile);
                    }
                } catch (error) {
                    console.error('Erro no processamento:', error);
                    showStatus(`Erro durante o processamento: ${error.message}`, 'error');
                } finally {
                    isProcessing = false;
                }
            });

            // Text action buttons with enhanced functionality
            setupTextActionButtons();

            // Language change handler
            document.getElementById('languageSelect').addEventListener('change', (e) => {
                const isJuridical = e.target.value === 'por+jur';
                const highlightCheckbox = document.getElementById('highlightTerms');
                
                if (highlightCheckbox) {
                    highlightCheckbox.disabled = !isJuridical;
                    if (!isJuridical) {
                        highlightCheckbox.checked = false;
                    }
                }
            });
        }

        // Enhanced text action buttons
        function setupTextActionButtons() {
            // Copy with format preservation
            document.getElementById('copyText').addEventListener('click', async () => {
                const editor = document.getElementById('editorContent');
                const htmlContent = editor.innerHTML;
                const textContent = editor.textContent || editor.innerText;
                
                if (!textContent.trim()) {
                    showStatus('Nenhum texto para copiar!', 'warning');
                    return;
                }

                try {
                    // Try to copy both HTML and plain text
                    if (navigator.clipboard && navigator.clipboard.write) {
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                'text/html': new Blob([htmlContent], { type: 'text/html' }),
                                'text/plain': new Blob([textContent], { type: 'text/plain' })
                            })
                        ]);
                        showStatus('Texto copiado com formatação preservada!', 'success');
                    } else {
                        // Fallback
                        await navigator.clipboard.writeText(textContent);
                        showStatus('Texto copiado (sem formatação)!', 'success');
                    }
                } catch (error) {
                    // Final fallback
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = textContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea);
                    showStatus('Texto copiado!', 'success');
                }
            });

            // Enhanced download with metadata
            document.getElementById('downloadTxt').addEventListener('click', () => {
                const editor = document.getElementById('editorContent');
                const text = editor.textContent || editor.innerText;
                
                if (!text.trim()) {
                    showStatus('Nenhum texto para baixar!', 'warning');
                    return;
                }

                const metadata = `OCR realizado em: ${new Date().toLocaleString()}
Idioma: ${document.getElementById('languageSelect').value}
Qualidade: ${document.getElementById('qualitySelect').value}
Estatísticas:
- Palavras: ${document.getElementById('wordCount').textContent}
- Caracteres: ${document.getElementById('charCount').textContent}
- Termos jurídicos: ${document.getElementById('legalTermsCount').textContent}
- Números de processo: ${document.getElementById('processCount').textContent}

${'='.repeat(50)}

${text}`;

                const blob = new Blob([metadata], { type: 'text/plain; charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ocr_${new Date().toISOString().split('T')[0]}_${Date.now()}.txt`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Arquivo baixado com metadados!', 'success');
            });

            // Advanced text cleaning
            document.getElementById('cleanText').addEventListener('click', () => {
                const editor = document.getElementById('editorContent');
                let text = editor.textContent || editor.innerText;
                
                if (!text.trim()) {
                    showStatus('Nenhum texto para limpar!', 'warning');
                    return;
                }

                // Apply advanced cleaning
                text = advancedTextCorrection(text);
                editor.textContent = text;
                
                // Update statistics
                updateStatistics(text, 0, 0);
                
                showStatus('Texto limpo e corrigido com algoritmos avançados!', 'success');
            });
        }

        // Handle multiple files
        function handleMultipleFiles(files) {
            const validFiles = files.filter(file => {
                try {
                    validateFile(file);
                    return true;
                } catch (error) {
                    showStatus(`Arquivo ${file.name}: ${error.message}`, 'error');
                    return false;
                }
            });

            if (validFiles.length === 0) {
                showStatus('Nenhum arquivo válido selecionado!', 'error');
                return;
            }

            currentFile = validFiles;

            // Show batch info
            fileInfo.innerHTML = `
                <div class="info-block">
                    <div class="info-line">
                        <i class="fas fa-files"></i>
                        <strong>Processamento em Lote:</strong> ${validFiles.length} arquivos
                    </div>
                    <div class="info-line">
                        <i class="fas fa-weight-hanging"></i>
                        <strong>Tamanho Total:</strong> ${(validFiles.reduce((sum, f) => sum + f.size, 0) / 1024 / 1024).toFixed(2)} MB
                    </div>
                    <div class="info-line">
                        <i class="fas fa-list"></i>
                        <strong>Arquivos:</strong> ${validFiles.map(f => f.name).join(', ')}
                    </div>
                </div>
            `;

            showElement(settingsCard);
            showStatus(`${validFiles.length} arquivos carregados para processamento em lote!`, 'success');
        }

        // Initialize complete application
        function initializeCompleteApp() {
            setupEventListeners();
            initAdvancedFeatures();
            setupPerformanceMonitoring();
            setupErrorRecovery();
            
            showStatus('Sistema OCR Avançado carregado! Recursos: Auto-save, Processamento em lote, Correções IA, Exportação multi-formato', 'success', 8000);
        }

        // Start application when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeCompleteApp);