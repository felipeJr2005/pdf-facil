<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Avan√ßado - Tesseract</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.min.js"></script>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #f72585;
            --success-color: #06d6a0;
            --warning-color: #f9844a;
            --error-color: #ef4444;
            --gray-100: #f8f9fa;
            --gray-300: #dee2e6;
            --gray-500: #6c757d;
            --gray-700: #495057;
            --gray-900: #212529;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--gray-100);
            color: var(--gray-900);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }

        .card-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-body {
            padding: 20px;
        }

        .drop-zone {
            border: 3px dashed var(--gray-300);
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--gray-100);
        }

        .drop-zone:hover,
        .drop-zone.drag-over {
            border-color: var(--primary-color);
            background: rgba(67, 97, 238, 0.05);
            transform: translateY(-2px);
        }

        .upload-icon {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 15px;
        }

        .upload-text {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--gray-700);
        }

        .upload-subtext {
            color: var(--gray-500);
        }

        .hidden {
            display: none !important;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(67, 97, 238, 0.3);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .settings-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .settings-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .settings-label {
            font-weight: 600;
            color: var(--gray-700);
        }

        .control-input {
            padding: 12px;
            border: 2px solid var(--gray-300);
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .control-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            appearance: none;
            background: var(--gray-300);
        }

        .progress-bar::-webkit-progress-bar {
            background: var(--gray-300);
            border-radius: 6px;
        }

        .progress-bar::-webkit-progress-value {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 6px;
        }

        .progress-text {
            margin-top: 10px;
            text-align: center;
            font-weight: 600;
            color: var(--gray-700);
        }

        .substep-text {
            margin-top: 5px;
            text-align: center;
            font-size: 0.9rem;
            color: var(--gray-500);
            font-style: italic;
        }

        .editor-content {
            min-height: 300px;
            max-height: 500px;
            overflow-y: auto;
            padding: 20px;
            border: 2px solid var(--gray-300);
            border-radius: 8px;
            background: white;
            font-family: 'Courier New', monospace;
            line-height: 1.8;
            white-space: pre-wrap;
        }

        .editor-content:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
        }

        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .processing-message {
            background: white;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .processing-message i {
            color: var(--primary-color);
            margin-bottom: 20px;
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-message.success {
            background: rgba(6, 214, 160, 0.1);
            color: var(--success-color);
            border: 1px solid rgba(6, 214, 160, 0.3);
        }

        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error-color);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .status-message.warning {
            background: rgba(249, 132, 74, 0.1);
            color: var(--warning-color);
            border: 1px solid rgba(249, 132, 74, 0.3);
        }

        .info-block {
            background: var(--gray-100);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .info-line {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            color: var(--gray-700);
        }

        .info-line:last-child {
            margin-bottom: 0;
        }

        .info-line i {
            color: var(--success-color);
            width: 16px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
        }

        .legal-term {
            background-color: rgba(144, 238, 144, 0.3);
            border-bottom: 2px dotted #4CAF50;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .process-number {
            background-color: rgba(173, 216, 230, 0.3);
            border-bottom: 2px dotted #2196F3;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .legal-reference {
            background-color: rgba(255, 182, 193, 0.3);
            border-bottom: 2px dotted #F44336;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .statistics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            background: var(--gray-100);
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--gray-500);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .card-body {
                padding: 15px;
            }
            
            .settings-panel {
                grid-template-columns: 1fr;
            }
            
            .statistics-panel {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Upload Area -->
        <div class="card">
            <div class="card-header">
                <h1 class="card-title">
                    <i class="fas fa-eye"></i>
                    OCR Avan√ßado com Tesseract
                </h1>
            </div>
            <div class="card-body">
                <div class="drop-zone" id="dropZone">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <div class="upload-text">Arraste arquivos ou clique para selecionar</div>
                    <div class="upload-subtext">Suporte para JPG, PNG e PDF (m√°x. 10MB)</div>
                    <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.pdf" style="display: none;">
                </div>
                <div id="fileInfo"></div>
            </div>
        </div>

        <!-- Settings -->
        <div class="card hidden" id="settingsCard">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-cogs"></i>
                    Configura√ß√µes de OCR
                </h2>
            </div>
            <div class="card-body">
                <div class="settings-panel">
                    <div class="settings-group">
                        <label class="settings-label">Idioma do Texto:</label>
                        <select class="control-input" id="languageSelect">
                            <option value="por">Portugu√™s</option>
                            <option value="por+jur">Portugu√™s Jur√≠dico</option>
                            <option value="eng">Ingl√™s</option>
                            <option value="spa">Espanhol</option>
                            <option value="fra">Franc√™s</option>
                            <option value="deu">Alem√£o</option>
                            <option value="ita">Italiano</option>
                        </select>
                    </div>
                    
                    <div class="settings-group">
                        <label class="settings-label">Qualidade do OCR:</label>
                        <select class="control-input" id="qualitySelect">
                            <option value="fast">R√°pido</option>
                            <option value="best" selected>Melhor Qualidade</option>
                            <option value="data_only">Apenas Dados</option>
                        </select>
                    </div>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="enhanceImage" checked>
                    <label for="enhanceImage">Melhorar qualidade da imagem automaticamente</label>
                </div>

                <div class="checkbox-group">
                    <input type="checkbox" id="highlightTerms">
                    <label for="highlightTerms">Destacar termos jur√≠dicos (apenas portugu√™s jur√≠dico)</label>
                </div>

                <button class="btn btn-primary" id="startOCR" style="width: 100%; margin-top: 20px;">
                    <i class="fas fa-magic"></i>
                    Iniciar Reconhecimento de Texto
                </button>
            </div>
        </div>

        <!-- Progress -->
        <div class="card hidden" id="progressCard">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-spinner fa-spin"></i>
                    Processando
                </h2>
            </div>
            <div class="card-body">
                <div class="progress-container">
                    <progress class="progress-bar" id="progressBar" value="0" max="100"></progress>
                    <div class="progress-text" id="progressText">Iniciando...</div>
                    <div class="substep-text" id="substepText"></div>
                </div>
            </div>
        </div>

        <!-- Results -->
        <div class="card hidden" id="resultsCard">
            <div class="card-header">
                <h2 class="card-title">
                    <i class="fas fa-file-alt"></i>
                    Texto Reconhecido
                </h2>
            </div>
            <div class="card-body">
                <div id="statisticsPanel" class="statistics-panel hidden">
                    <div class="stat-item">
                        <span class="stat-value" id="wordCount">0</span>
                        <span class="stat-label">Palavras</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="charCount">0</span>
                        <span class="stat-label">Caracteres</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="legalTermsCount">0</span>
                        <span class="stat-label">Termos Jur√≠dicos</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="processCount">0</span>
                        <span class="stat-label">Processos</span>
                    </div>
                </div>

                <div id="editorContent" class="editor-content" contenteditable="true" 
                     placeholder="O texto reconhecido aparecer√° aqui..."></div>
                
                <div style="margin-top: 20px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-success" id="copyText">
                        <i class="fas fa-copy"></i>
                        Copiar Texto
                    </button>
                    <button class="btn btn-primary" id="downloadTxt">
                        <i class="fas fa-download"></i>
                        Baixar TXT
                    </button>
                    <button class="btn btn-warning" id="cleanText">
                        <i class="fas fa-broom"></i>
                        Limpar Texto
                    </button>
                </div>
            </div>
        </div>

        <!-- Status Messages -->
        <div id="statusArea"></div>
    </div>

    <!-- Processing Overlay -->
    <div class="processing-overlay hidden" id="processingOverlay">
        <div class="processing-message">
            <i class="fas fa-spinner fa-spin fa-3x"></i>
            <h3 id="overlayTitle">Processando OCR...</h3>
            <p id="overlayMessage">Aguarde enquanto processamos seu arquivo</p>
        </div>
    </div>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.worker.min.js';

        // Global variables
        let currentFile = null;
        let isProcessing = false;

        // Legal terms for highlighting
        const LEGAL_TERMS = [
            'habeas corpus', 'mandado de seguran√ßa', 'recurso especial', 'recurso extraordin√°rio',
            'agravo de instrumento', 'apela√ß√£o', 'embargos', 'liminar', 'tutela antecipada',
            'jurisprud√™ncia', 's√∫mula', 'precedente', 'ac√≥rd√£o', 'senten√ßa', 'decis√£o',
            'prescri√ß√£o', 'decad√™ncia', 'litispend√™ncia', 'coisa julgada', 'm√©rito',
            'relator', 'revisor', 'ministro', 'desembargador', 'juiz', 'audi√™ncia',
            'julgamento', 'ementa', 'autor', 'r√©u', 'procurador', 'advogado'
        ];

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const settingsCard = document.getElementById('settingsCard');
        const progressCard = document.getElementById('progressCard');
        const resultsCard = document.getElementById('resultsCard');
        const statusArea = document.getElementById('statusArea');
        const processingOverlay = document.getElementById('processingOverlay');

        // Utility functions
        function showStatus(message, type = 'info', duration = 5000) {
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message ${type}`;
            statusDiv.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                ${message}
            `;
            
            statusArea.appendChild(statusDiv);
            
            if (duration > 0) {
                setTimeout(() => {
                    if (statusDiv.parentNode) {
                        statusDiv.parentNode.removeChild(statusDiv);
                    }
                }, duration);
            }
        }

        function updateProgress(value, text, subtext = '') {
            document.getElementById('progressBar').value = value;
            document.getElementById('progressText').textContent = text;
            document.getElementById('substepText').textContent = subtext;
        }

        function showElement(element) {
            if (typeof element === 'string') {
                element = document.getElementById(element);
            }
            if (element) {
                element.classList.remove('hidden');
            }
        }

        function hideElement(element) {
            if (typeof element === 'string') {
                element = document.getElementById(element);
            }
            if (element) {
                element.classList.add('hidden');
            }
        }

        // File validation
        function validateFile(file) {
            const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'application/pdf'];
            const maxSize = 10 * 1024 * 1024; // 10MB

            if (!validTypes.includes(file.type)) {
                throw new Error('Tipo de arquivo n√£o suportado. Use JPG, PNG ou PDF.');
            }

            if (file.size > maxSize) {
                throw new Error('Arquivo muito grande. M√°ximo 10MB.');
            }

            return true;
        }

        // Image enhancement for better OCR
        async function enhanceImage(imageData) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageDataObj.data;

                    // Convert to grayscale and enhance contrast
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        // Apply contrast enhancement
                        const enhanced = Math.min(255, Math.max(0, (avg - 128) * 1.5 + 128));
                        data[i] = enhanced;
                        data[i + 1] = enhanced;
                        data[i + 2] = enhanced;
                    }

                    ctx.putImageData(imageDataObj, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };

                img.src = imageData;
            });
        }

        // Advanced text cleaning for legal documents
        function cleanOCRText(text) {
            // Basic cleanup
            text = text.replace(/\r\n/g, '\n');
            text = text.replace(/\t/g, ' ');
            text = text.replace(/ {2,}/g, ' ');

            // Fix common OCR mistakes
            const corrections = {
                '0': 'O', // Zero to letter O in specific contexts
                'lJusti√ßa': 'Justi√ßa',
                'Trjbunal': 'Tribunal',
                'Julgarnento': 'Julgamento',
                'artjgo': 'artigo',
                'paragrato': 'par√°grafo',
                'Codigo': 'C√≥digo',
                'Lei no': 'Lei n¬∫',
                'a√ß√£0': 'a√ß√£o',
                'ment0': 'mento',
                '√ß√£0': '√ß√£o',
                'n√£0': 'n√£o'
            };

            // Apply corrections
            for (const [wrong, correct] of Object.entries(corrections)) {
                const regex = new RegExp(wrong, 'gi');
                text = text.replace(regex, correct);
            }

            // Fix legal references format
            text = text.replace(/lei\s+n[¬∞¬∫]?\s*([0-9.]+)\/([0-9]{4})/gi, 'Lei n¬∫ $1/$2');
            text = text.replace(/art\.?\s*(\d+)[,.]\s*([a-z√†-√∫])/gi, 'art. $1, $2');

            // Format legal headers
            text = text.replace(/AC√ìRD√ÉO/gi, '\n\nAC√ìRD√ÉO\n');
            text = text.replace(/RELAT√ìRIO/gi, '\n\nRELAT√ìRIO\n');
            text = text.replace(/DECIS√ÉO/gi, '\n\nDECIS√ÉO\n');
            text = text.replace(/SENTEN√áA/gi, '\n\nSENTEN√áA\n');

            // Remove excessive line breaks
            text = text.replace(/\n{3,}/g, '\n\n');

            return text.trim();
        }

        // Identify and highlight legal terms
        function highlightLegalTerms(text) {
            let highlightedText = text;
            let termsFound = [];
            let processNumbers = [];

            // Highlight legal terms
            LEGAL_TERMS.forEach(term => {
                const regex = new RegExp(`\\b${term}\\b`, 'gi');
                if (regex.test(text)) {
                    termsFound.push(term);
                    highlightedText = highlightedText.replace(regex, `<span class="legal-term">$&</span>`);
                }
            });

            // Highlight process numbers (Brazilian format)
            const processRegex = /\d{7}-\d{2}\.\d{4}\.\d\.\d{2}\.\d{4}/g;
            const processes = text.match(processRegex) || [];
            processes.forEach(process => {
                processNumbers.push(process);
                highlightedText = highlightedText.replace(
                    new RegExp(process.replace(/[-./]/g, '[-./]?'), 'g'),
                    `<span class="process-number">${process}</span>`
                );
            });

            // Update statistics
            updateStatistics(text, termsFound.length, processNumbers.length);

            return highlightedText;
        }

        // Update text statistics
        function updateStatistics(text, legalTermsCount, processCount) {
            const words = text.trim().split(/\s+/).length;
            const chars = text.length;

            document.getElementById('wordCount').textContent = words;
            document.getElementById('charCount').textContent = chars;
            document.getElementById('legalTermsCount').textContent = legalTermsCount;
            document.getElementById('processCount').textContent = processCount;

            showElement('statisticsPanel');
        }

      // Main OCR processing function
        async function processOCR(imageData, language) {
            showElement(processingOverlay);
            document.getElementById('overlayTitle').textContent = 'Processando OCR...';
            document.getElementById('overlayMessage').textContent = 'Analisando imagem e reconhecendo texto';

            try {
                // Enhance image if option is selected
                let processedImage = imageData;
                if (document.getElementById('enhanceImage').checked) {
                    updateProgress(10, 'Melhorando qualidade da imagem...', 'Aplicando filtros de contraste e nitidez');
                    processedImage = await enhanceImage(imageData);
                }

                // Configure Tesseract options
                const quality = document.getElementById('qualitySelect').value;
                let tessOptions = {
                    logger: (m) => {
                        if (m.status === 'recognizing text') {
                            const progress = 20 + (m.progress * 70);
                            updateProgress(progress, 'Reconhecendo texto...', `${Math.round(m.progress * 100)}% conclu√≠do`);
                        }
                    }
                };

                // Advanced settings for legal Portuguese
                if (language === 'por+jur') {
                    tessOptions = {
                        ...tessOptions,
                        tessedit_pageseg_mode: '6',
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√ø0123456789.,;:!?()[]{}#$%&*+-=@"\'\\/¬ß¬∫¬∞¬™<>|_',
                        preserve_interword_spaces: '1'
                    };
                    language = 'por'; // Use Portuguese as base
                }

                // Quality-specific settings
                switch (quality) {
                    case 'fast':
                        tessOptions.tessedit_pageseg_mode = '1';
                        tessOptions.tessedit_ocr_engine_mode = '1';
                        break;
                    case 'best':
                        tessOptions.tessedit_pageseg_mode = '6';
                        tessOptions.tessedit_ocr_engine_mode = '1';
                        tessOptions.tessedit_char_blacklist = '';
                        break;
                    case 'data_only':
                        tessOptions.tessedit_pageseg_mode = '6';
                        tessOptions.tessedit_create_hocr = '1';
                        break;
                }

                updateProgress(20, 'Iniciando reconhecimento OCR...', 'Configurando Tesseract');

                // Perform OCR
                const result = await Tesseract.recognize(processedImage, language, tessOptions);
                
                updateProgress(90, 'Processando texto reconhecido...', 'Aplicando corre√ß√µes e formata√ß√£o');

                // Clean and process the text
                let cleanedText = cleanOCRText(result.data.text);
                
                // Apply highlighting if enabled and using legal Portuguese
                if (document.getElementById('highlightTerms').checked && document.getElementById('languageSelect').value === 'por+jur') {
                    cleanedText = highlightLegalTerms(cleanedText);
                    document.getElementById('editorContent').innerHTML = cleanedText;
                } else {
                    document.getElementById('editorContent').textContent = cleanedText;
                    updateStatistics(cleanedText, 0, 0);
                }

                updateProgress(100, 'Conclu√≠do!', 'Texto reconhecido com sucesso');

                // Show results
                hideElement(progressCard);
                hideElement(processingOverlay);
                showElement(resultsCard);

                showStatus('Texto reconhecido com sucesso!', 'success');

                return cleanedText;

            } catch (error) {
                console.error('Erro no OCR:', error);
                hideElement(processingOverlay);
                hideElement(progressCard);
                showStatus(`Erro no reconhecimento: ${error.message}`, 'error');
                throw error;
            }
        }

        // Enhanced OCR with multiple attempts for better accuracy
        async function processOCRWithRetry(imageData, language, maxRetries = 2) {
            let bestResult = null;
            let bestConfidence = 0;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    updateProgress(
                        (attempt - 1) * (90 / maxRetries), 
                        `Tentativa ${attempt} de ${maxRetries}...`, 
                        'Processando com diferentes configura√ß√µes'
                    );

                    const result = await Tesseract.recognize(imageData, language, {
                        logger: (m) => {
                            if (m.status === 'recognizing text') {
                                const baseProgress = (attempt - 1) * (90 / maxRetries);
                                const currentProgress = baseProgress + (m.progress * (90 / maxRetries));
                                updateProgress(currentProgress, `Tentativa ${attempt}: Reconhecendo...`, `${Math.round(m.progress * 100)}%`);
                            }
                        },
                        tessedit_pageseg_mode: attempt === 1 ? '6' : '1',
                        tessedit_ocr_engine_mode: attempt === 1 ? '1' : '2'
                    });

                    const confidence = result.data.confidence;
                    if (confidence > bestConfidence) {
                        bestConfidence = confidence;
                        bestResult = result;
                    }

                    // If confidence is high enough, stop trying
                    if (confidence > 85) {
                        break;
                    }

                } catch (error) {
                    console.warn(`Tentativa ${attempt} falhou:`, error);
                    if (attempt === maxRetries) {
                        throw error;
                    }
                }
            }

            return bestResult || { data: { text: '', confidence: 0 } };
        }

        // Process PDF files with enhanced error handling
        async function processPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const numPages = pdf.numPages;

            let allText = '';
            let successfulPages = 0;
            let failedPages = [];

            updateProgress(5, 'Carregando PDF...', `${numPages} p√°ginas detectadas`);

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                try {
                    updateProgress(
                        5 + ((pageNum - 1) / numPages) * 85,
                        `Processando p√°gina ${pageNum} de ${numPages}`,
                        'Extraindo conte√∫do da p√°gina PDF'
                    );

                    const page = await pdf.getPage(pageNum);
                    const scale = 2.0; // Higher scale for better quality
                    const viewport = page.getViewport({ scale });

                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;

                    const imageData = canvas.toDataURL('image/png');
                    const language = document.getElementById('languageSelect').value;
                    
                    // Process individual page with retry mechanism
                    const result = await processOCRWithRetry(imageData, language);
                    const pageText = cleanOCRText(result.data.text);
                    
                    if (pageText.trim()) {
                        allText += `\n\n--- P√°gina ${pageNum} ---\n\n${pageText}`;
                        successfulPages++;
                    } else {
                        failedPages.push(pageNum);
                        allText += `\n\n--- P√°gina ${pageNum} (sem texto detectado) ---\n\n`;
                    }

                } catch (error) {
                    console.error(`Erro na p√°gina ${pageNum}:`, error);
                    failedPages.push(pageNum);
                    allText += `\n\n--- P√°gina ${pageNum} (erro no processamento) ---\n\n`;
                }
            }

            // Update final results
            updateProgress(90, 'Finalizando processamento...', 'Aplicando formata√ß√£o final');

            const finalText = allText.trim();
            
            // Apply highlighting if enabled
            if (document.getElementById('highlightTerms').checked && document.getElementById('languageSelect').value === 'por+jur') {
                const highlightedText = highlightLegalTerms(finalText);
                document.getElementById('editorContent').innerHTML = highlightedText;
            } else {
                document.getElementById('editorContent').textContent = finalText;
                updateStatistics(finalText, 0, 0);
            }

            updateProgress(100, 'PDF processado!', `${successfulPages}/${numPages} p√°ginas processadas com sucesso`);

            // Show summary
            if (failedPages.length > 0) {
                showStatus(
                    `PDF processado! ${successfulPages} p√°ginas com sucesso. ${failedPages.length} p√°ginas falharam: ${failedPages.join(', ')}`, 
                    'warning'
                );
            } else {
                showStatus(`PDF processado com sucesso! Todas as ${numPages} p√°ginas foram processadas.`, 'success');
            }

            hideElement(progressCard);
            hideElement(processingOverlay);
            showElement(resultsCard);

            return finalText;
        }

        // Batch processing for multiple images
        async function processBatchImages(files) {
            let allResults = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    updateProgress(
                        (i / files.length) * 90,
                        `Processando arquivo ${i + 1} de ${files.length}`,
                        `Arquivo: ${file.name}`
                    );

                    const reader = new FileReader();
                    const imageData = await new Promise((resolve) => {
                        reader.onload = (e) => resolve(e.target.result);
                        reader.readAsDataURL(file);
                    });

                    const language = document.getElementById('languageSelect').value;
                    const result = await processOCRWithRetry(imageData, language);
                    const cleanedText = cleanOCRText(result.data.text);

                    allResults.push({
                        filename: file.name,
                        text: cleanedText,
                        confidence: result.data.confidence
                    });

                } catch (error) {
                    console.error(`Erro processando ${file.name}:`, error);
                    allResults.push({
                        filename: file.name,
                        text: `Erro no processamento: ${error.message}`,
                        confidence: 0
                    });
                }
            }

            // Combine all results
            const combinedText = allResults.map(result => 
                `--- ${result.filename} (Confian√ßa: ${Math.round(result.confidence)}%) ---\n\n${result.text}`
            ).join('\n\n');

            updateProgress(100, 'Processamento em lote conclu√≠do!', `${allResults.length} arquivos processados`);

            document.getElementById('editorContent').textContent = combinedText;
            updateStatistics(combinedText, 0, 0);

            hideElement(progressCard);
            hideElement(processingOverlay);
            showElement(resultsCard);

            return combinedText;
        }

        // Advanced text post-processing with AI-like corrections
        function advancedTextCorrection(text) {
            // Dictionary of common legal terms and their corrections
            const legalCorrections = {
                // Common OCR mistakes in legal documents
                'Supremo Trihunal': 'Supremo Tribunal',
                'Superior Trihunal': 'Superior Tribunal',
                'Trihunal de Justica': 'Tribunal de Justi√ßa',
                'Ministerio Puhlico': 'Minist√©rio P√∫blico',
                'Defensoria Puhlica': 'Defensoria P√∫blica',
                'habeas corpus': 'habeas corpus',
                'mandado de seguranca': 'mandado de seguran√ßa',
                'recurso especial': 'recurso especial',
                'recurso extraordinario': 'recurso extraordin√°rio',
                'agravo de instrumento': 'agravo de instrumento',
                'a√ßao civil publica': 'a√ß√£o civil p√∫blica',
                'a√ßao de indenizacao': 'a√ß√£o de indeniza√ß√£o',
                'a√ßao de cobranca': 'a√ß√£o de cobran√ßa',
                'execucao fiscal': 'execu√ß√£o fiscal',
                'embargos a execucao': 'embargos √† execu√ß√£o',
                'embargos de declaracao': 'embargos de declara√ß√£o',
                'apelacao civel': 'apela√ß√£o c√≠vel',
                'apelacao criminal': 'apela√ß√£o criminal',
                'agravo regimental': 'agravo regimental',
                'agravo interno': 'agravo interno',
                'suspensao de seguranca': 'suspens√£o de seguran√ßa',
                'suspensao de liminar': 'suspens√£o de liminar',
                'medida cautelar': 'medida cautelar',
                'tutela antecipada': 'tutela antecipada',
                'tutela provisoria': 'tutela provis√≥ria',
                'liminar': 'liminar',
                'jurisprudencia': 'jurisprud√™ncia',
                'sumula': 's√∫mula',
                'precedente': 'precedente',
                'acordao': 'ac√≥rd√£o',
                'sentenca': 'senten√ßa',
                'decisao': 'decis√£o',
                'despacho': 'despacho',
                'prescricao': 'prescri√ß√£o',
                'decadencia': 'decad√™ncia',
                'litispendencia': 'litispend√™ncia',
                'coisa julgada': 'coisa julgada',
                'merito': 'm√©rito',
                'processo': 'processo',
                'procedimento': 'procedimento',
                'peti√ß√£o': 'peti√ß√£o',
                'peticao': 'peti√ß√£o',
                'contestacao': 'contesta√ß√£o',
                'replica': 'tr√≠plica',
                'treplicaa': 'tr√≠plica',
                'impugnacao': 'impugna√ß√£o',
                'recurso': 'recurso',
                'contra-razoes': 'contra-raz√µes',
                'razoes': 'raz√µes',
                'memoriais': 'memoriais',
                'alegacoes': 'alega√ß√µes',
                'alegacoes finais': 'alega√ß√µes finais',
                'instrucao': 'instru√ß√£o',
                'audiencia': 'audi√™ncia',
                'julgamento': 'julgamento',
                'deliberacao': 'delibera√ß√£o',
                'votacao': 'vota√ß√£o',
                'ementa': 'ementa',
                'relatorio': 'relat√≥rio',
                'voto': 'voto',
                'declaracao': 'declara√ß√£o'
            };

            // Apply legal corrections
            let correctedText = text;
            Object.entries(legalCorrections).forEach(([wrong, correct]) => {
                const regex = new RegExp(wrong, 'gi');
                correctedText = correctedText.replace(regex, correct);
            });

            // Fix common number/letter confusions
            correctedText = correctedText.replace(/(?<!\d)0(?=\s+[a-z√°√†√¢√£√©√®√™√≠√Ø√≥√¥√µ√∂√∫√ß√±])/g, 'O'); // 0 before words -> O
            correctedText = correctedText.replace(/(?<=^|\s)1(?=\s*[Jj]ustice|[Jj]uiz|[Jj]ulg)/g, 'J'); // 1 before judge-related words -> J
            correctedText = correctedText.replace(/(?<=^|\s)l(?=\s*[Jj]ustice|[Jj]uiz|[Jj]ulg)/g, 'J'); // l before judge-related words -> J

            // Fix date formats
            correctedText = correctedText.replace(/(\d{1,2})\s*de\s+([a-z]+)\s+de\s+(\d{4})/gi, '$1 de $2 de $3');
            correctedText = correctedText.replace(/(\d{1,2})\/(\d{1,2})\/(\d{4})/g, '$1/$2/$3');

            // Fix currency formats
            correctedText = correctedText.replace(/R\$\s*(\d+)[\.,](\d{3})[\.,](\d{2})/g, 'R$ $1.$2,$3');
            correctedText = correctedText.replace(/R\$\s*(\d+)[\.,](\d{2})(?!\d)/g, 'R$ $1,$2');

            // Fix legal citations
            correctedText = correctedText.replace(/art\.?\s*(\d+)[¬∞¬∫]*[,.\s]*([a-z√†-√∫¬ß¬∞¬∫\d\s]*)/gi, (match, artNum, rest) => {
                return `art. ${artNum}${rest ? ', ' + rest.trim() : ''}`;
            });

            // Fix law references
            correctedText = correctedText.replace(/(lei|decreto|portaria|resolu√ß√£o)\s+n[¬∞¬∫]?\s*([0-9.]+)\/(\d{4})/gi, '$1 n¬∫ $2/$3');

            // Fix paragraph references
            correctedText = correctedText.replace(/¬ß\s*(\d+)[¬∞¬∫]*/g, '¬ß $1¬∫');

            // Fix common spacing issues
            correctedText = correctedText.replace(/\s+/g, ' '); // Multiple spaces to single
            correctedText = correctedText.replace(/\n\s*\n\s*\n+/g, '\n\n'); // Multiple line breaks to double
            correctedText = correctedText.replace(/([.!?])\s*\n\s*([A-Z√Å√Ä√Ç√É√â√à√ä√ç√è√ì√î√ï√ñ√ö√á√ë])/g, '$1\n\n$2'); // Add double break after sentences

            return correctedText.trim();
        }

        // Export functionality with multiple formats
        function setupAdvancedExport() {
            // Export as formatted HTML
            function exportAsHTML() {
                const editor = document.getElementById('editorContent');
                const content = editor.innerHTML || editor.textContent;
                
                const htmlContent = `
                <!DOCTYPE html>
                <html lang="pt-BR">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Texto OCR - ${new Date().toLocaleDateString()}</title>
                    <style>
                        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
                        .legal-term { background-color: rgba(144, 238, 144, 0.3); border-bottom: 2px dotted #4CAF50; }
                        .process-number { background-color: rgba(173, 216, 230, 0.3); border-bottom: 2px dotted #2196F3; font-weight: bold; }
                        .legal-reference { background-color: rgba(255, 182, 193, 0.3); border-bottom: 2px dotted #F44336; font-weight: bold; }
                        h1 { color: #333; border-bottom: 2px solid #4361ee; padding-bottom: 10px; }
                    </style>
                </head>
                <body>
                    <h1>Texto Reconhecido por OCR</h1>
                    <p><strong>Data:</strong> ${new Date().toLocaleString()}</p>
                    <hr>
                    <div>${content}</div>
                </body>
                </html>`;

                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `texto_ocr_${new Date().getTime()}.html`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Arquivo HTML exportado com sucesso!', 'success');
            }

            // Export as JSON with metadata
            function exportAsJSON() {
                const editor = document.getElementById('editorContent');
                const text = editor.textContent || editor.innerText;
                
                const data = {
                    timestamp: new Date().toISOString(),
                    language: document.getElementById('languageSelect').value,
                    quality: document.getElementById('qualitySelect').value,
                    statistics: {
                        words: document.getElementById('wordCount').textContent,
                        characters: document.getElementById('charCount').textContent,
                        legalTerms: document.getElementById('legalTermsCount').textContent,
                        processes: document.getElementById('processCount').textContent
                    },
                    content: text,
                    htmlContent: editor.innerHTML
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `dados_ocr_${new Date().getTime()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Dados exportados em JSON com sucesso!', 'success');
            }

            // Add export buttons
            const exportButtons = `
                <button class="btn btn-primary" onclick="exportAsHTML()">
                    <i class="fas fa-code"></i>
                    Exportar HTML
                </button>
                <button class="btn btn-warning" onclick="exportAsJSON()">
                    <i class="fas fa-database"></i>
                    Exportar JSON
                </button>
            `;

            // Make functions global for onclick handlers
            window.exportAsHTML = exportAsHTML;
            window.exportAsJSON = exportAsJSON;

            return exportButtons;
        }

        // Initialize advanced features
        function initAdvancedFeatures() {
            // Add export buttons to results card
            const resultsCard = document.getElementById('resultsCard');
            if (resultsCard) {
                const buttonContainer = resultsCard.querySelector('.card-body > div:last-child');
                if (buttonContainer) {
                    buttonContainer.innerHTML += setupAdvancedExport();
                }
            }

            // Add keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 's':
                            e.preventDefault();
                            document.getElementById('downloadTxt').click();
                            break;
                        case 'k':
                            e.preventDefault();
                            document.getElementById('copyText').click();
                            break;
                        case 'n':
                            e.preventDefault();
                            document.getElementById('cleanText').click();
                            break;
                        case 'e':
                            e.preventDefault();
                            if (typeof exportAsHTML === 'function') exportAsHTML();
                            break;
                        case 'j':
                            e.preventDefault();
                            if (typeof exportAsJSON === 'function') exportAsJSON();
                            break;
                    }
                }
            });

            // Add tooltips for better UX
            addTooltips();

            // Initialize auto-save functionality
            setupAutoSave();

            // Setup confidence threshold alerts
            setupConfidenceAlerts();

            showStatus('Funcionalidades avan√ßadas carregadas! Use Ctrl+S (salvar), Ctrl+K (copiar), Ctrl+N (limpar), Ctrl+E (HTML), Ctrl+J (JSON)', 'success');
        }

        // Add helpful tooltips
        function addTooltips() {
            const tooltips = {
                'enhanceImage': 'Aplica filtros de contraste e nitidez para melhorar a precis√£o do OCR',
                'highlightTerms': 'Destaca automaticamente termos jur√≠dicos, n√∫meros de processo e refer√™ncias legais',
                'languageSelect': 'Portugu√™s Jur√≠dico oferece configura√ß√µes otimizadas para documentos legais',
                'qualitySelect': 'Melhor Qualidade demora mais mas oferece maior precis√£o',
                'startOCR': 'Inicia o processamento OCR com as configura√ß√µes selecionadas'
            };

            Object.entries(tooltips).forEach(([id, text]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.title = text;
                    element.setAttribute('data-tooltip', text);
                }
            });
        }

        // Auto-save functionality
        function setupAutoSave() {
            let autoSaveInterval;
            const AUTOSAVE_DELAY = 30000; // 30 seconds

            function startAutoSave() {
                clearInterval(autoSaveInterval);
                autoSaveInterval = setInterval(() => {
                    const editor = document.getElementById('editorContent');
                    const content = editor.textContent || editor.innerText;
                    
                    if (content.trim()) {
                        localStorage.setItem('ocr_autosave', JSON.stringify({
                            content: content,
                            timestamp: new Date().toISOString(),
                            language: document.getElementById('languageSelect').value
                        }));
                        
                        // Show subtle auto-save indicator
                        showAutoSaveIndicator();
                    }
                }, AUTOSAVE_DELAY);
            }

            function showAutoSaveIndicator() {
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(6, 214, 160, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 0.8rem;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                indicator.innerHTML = '<i class="fas fa-save"></i> Auto-salvo';
                document.body.appendChild(indicator);

                // Animate in
                setTimeout(() => indicator.style.opacity = '1', 100);
                
                // Animate out and remove
                setTimeout(() => {
                    indicator.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(indicator), 300);
                }, 2000);
            }

            function loadAutoSave() {
                const saved = localStorage.getItem('ocr_autosave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        const timeDiff = new Date() - new Date(data.timestamp);
                        const hoursDiff = timeDiff / (1000 * 60 * 60);
                        
                        if (hoursDiff < 24) { // Only restore if less than 24 hours old
                            if (confirm(`Encontrado texto auto-salvo de ${new Date(data.timestamp).toLocaleString()}. Deseja restaurar?`)) {
                                document.getElementById('editorContent').textContent = data.content;
                                document.getElementById('languageSelect').value = data.language || 'por';
                                showElement('resultsCard');
                                showStatus('Texto auto-salvo restaurado com sucesso!', 'success');
                            }
                        }
                    } catch (error) {
                        console.error('Erro ao carregar auto-save:', error);
                    }
                }
            }

            // Start auto-save when editor has content
            document.addEventListener('DOMContentLoaded', () => {
                loadAutoSave();
                
                const editor = document.getElementById('editorContent');
                if (editor) {
                    editor.addEventListener('input', () => {
                        if (editor.textContent.trim()) {
                            startAutoSave();
                        }
                    });
                }
            });
        }

        // Confidence threshold alerts
        function setupConfidenceAlerts() {
            window.checkOCRConfidence = function(confidence) {
                if (confidence < 60) {
                    showStatus(
                        `Baixa confian√ßa no reconhecimento (${Math.round(confidence)}%). Considere melhorar a qualidade da imagem ou usar configura√ß√µes diferentes.`,
                        'warning',
                        8000
                    );
                } else if (confidence < 80) {
                    showStatus(
                        `Confian√ßa moderada (${Math.round(confidence)}%). Revise o texto para poss√≠veis erros.`,
                        'warning',
                        5000
                    );
                } else {
                    showStatus(
                        `Alta confian√ßa no reconhecimento (${Math.round(confidence)}%)!`,
                        'success',
                        3000
                    );
                }
            };
        }

        // Advanced image preprocessing with multiple filters
        async function advancedImagePreprocessing(imageData) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();

                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageDataObj = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageDataObj.data;

                    // Apply multiple enhancement filters
                    applyGrayscaleFilter(data);
                    applyContrastEnhancement(data, 1.5);
                    applyNoiseReduction(data, canvas.width, canvas.height);
                    applySharpening(data, canvas.width, canvas.height);
                    applyBinarization(data, calculateOtsuThreshold(data));

                    ctx.putImageData(imageDataObj, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };

                img.src = imageData;
            });
        }

        // Individual image filter functions
        function applyGrayscaleFilter(data) {
            for (let i = 0; i < data.length; i += 4) {
                const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
        }

        function applyContrastEnhancement(data, factor) {
            const intercept = 128 * (1 - factor);
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] * factor + intercept));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * factor + intercept));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * factor + intercept));
            }
        }

        function applyNoiseReduction(data, width, height) {
            const tempData = new Uint8ClampedArray(data);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    let sum = 0;
                    let count = 0;
                    
                    // 3x3 median filter
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nidx = ((y + dy) * width + (x + dx)) * 4;
                            sum += tempData[nidx];
                            count++;
                        }
                    }
                    
                    const avg = sum / count;
                    data[idx] = data[idx + 1] = data[idx + 2] = avg;
                }
            }
        }

        function applySharpening(data, width, height) {
            const tempData = new Uint8ClampedArray(data);
            const kernel = [-1, -1, -1, -1, 9, -1, -1, -1, -1];
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    let sum = 0;
                    
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const kidx = ((y + ky) * width + (x + kx)) * 4;
                            const kernelIdx = (ky + 1) * 3 + (kx + 1);
                            sum += tempData[kidx] * kernel[kernelIdx];
                        }
                    }
                    
                    const result = Math.min(255, Math.max(0, sum));
                    data[idx] = data[idx + 1] = data[idx + 2] = result;
                }
            }
        }

        function calculateOtsuThreshold(data) {
            const histogram = new Array(256).fill(0);
            const total = data.length / 4;
            
            // Build histogram
            for (let i = 0; i < data.length; i += 4) {
                histogram[Math.round(data[i])]++;
            }
            
            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }
            
            let sumB = 0;
            let wB = 0;
            let wF = 0;
            let varMax = 0;
            let threshold = 0;
            
            for (let i = 0; i < 256; i++) {
                wB += histogram[i];
                if (wB === 0) continue;
                
                wF = total - wB;
                if (wF === 0) break;
                
                sumB += i * histogram[i];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);
                
                if (varBetween > varMax) {
                    varMax = varBetween;
                    threshold = i;
                }
            }
            
            return threshold;
        }

        function applyBinarization(data, threshold) {
            for (let i = 0; i < data.length; i += 4) {
                const value = data[i] > threshold ? 255 : 0;
                data[i] = data[i + 1] = data[i + 2] = value;
            }
        }

        // Performance monitoring
        function setupPerformanceMonitoring() {
            const performanceData = {
                startTime: null,
                endTime: null,
                filesProcessed: 0,
                totalCharacters: 0,
                averageConfidence: 0
            };

            window.startPerformanceTracking = function() {
                performanceData.startTime = performance.now();
            };

            window.endPerformanceTracking = function(confidence, characterCount) {
                performanceData.endTime = performance.now();
                performanceData.filesProcessed++;
                performanceData.totalCharacters += characterCount;
                performanceData.averageConfidence = 
                    (performanceData.averageConfidence * (performanceData.filesProcessed - 1) + confidence) / performanceData.filesProcessed;

                const processingTime = (performanceData.endTime - performanceData.startTime) / 1000;
                const charactersPerSecond = characterCount / processingTime;

                console.log(`Performance Stats:
                    - Tempo de processamento: ${processingTime.toFixed(2)}s
                    - Caracteres por segundo: ${charactersPerSecond.toFixed(2)}
                    - Confian√ßa m√©dia: ${performanceData.averageConfidence.toFixed(1)}%
                    - Total de arquivos: ${performanceData.filesProcessed}
                    - Total de caracteres: ${performanceData.totalCharacters.toLocaleString()}`);

                // Show performance alert if processing is slow
                if (charactersPerSecond < 50) {
                    showStatus('Processamento lento detectado. Considere usar qualidade "R√°pido" para arquivos grandes.', 'warning', 6000);
                }
            };
        }

        // Enhanced error handling and recovery
        function setupErrorRecovery() {
            window.addEventListener('error', (event) => {
                console.error('Erro global capturado:', event.error);
                
                // Try to recover from common errors
                if (event.error.message.includes('Tesseract')) {
                    showStatus('Erro no Tesseract detectado. Tentando reinicializar...', 'warning');
                    
                    // Attempt to reload Tesseract
                    setTimeout(() => {
                        location.reload();
                    }, 3000);
                } else if (event.error.message.includes('memory') || event.error.message.includes('Memory')) {
                    showStatus('Erro de mem√≥ria detectado. Considere processar arquivos menores ou recarregar a p√°gina.', 'error', 10000);
                }
            });

            // Handle unhandled promise rejections
            window.addEventListener('unhandledrejection', (event) => {
                console.error('Promise rejeitada:', event.reason);
                showStatus('Erro inesperado no processamento. Verifique o console para detalhes.', 'error', 5000);
                event.preventDefault();
            });
        }

        // Language detection helper
        async function detectLanguage(text) {
            const languagePatterns = {
                por: /\b(que|com|para|uma|dos|pela|mais|como|seu|tem|foi|muito|pode|s√£o|entre|quando|ainda|pelo|sobre|onde|sendo|ap√≥s|durante|atrav√©s|portanto|contudo|entretanto)\b/gi,
                eng: /\b(the|and|for|are|but|not|you|all|can|had|her|was|one|our|out|day|get|has|him|his|how|its|may|new|now|old|see|two|way|who|boy|did|man|men|too|any|car|each|end|even|here|off|put|say|she|try|use)\b/gi,
                spa: /\b(que|con|para|una|por|m√°s|como|sus|fue|muy|puede|son|entre|cuando|a√∫n|sobre|donde|siendo|despu√©s|durante|trav√©s|por tanto|sin embargo)\b/gi,
                fra: /\b(que|avec|pour|une|par|plus|comme|ses|√©tait|tr√®s|peut|sont|entre|quand|encore|sur|o√π|√©tant|apr√®s|pendant|√† travers|par cons√©quent|cependant)\b/gi
            };

            let bestMatch = 'por';
            let maxMatches = 0;

            Object.entries(languagePatterns).forEach(([lang, pattern]) => {
                const matches = (text.match(pattern) || []).length;
                if (matches > maxMatches) {
                    maxMatches = matches;
                    bestMatch = lang;
                }
            });

            return bestMatch;
        }

        // Complete event listener setup
        function setupEventListeners() {
            // File handling
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.add('drag-over');
                });
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.classList.remove('drag-over');
                });
            });

            dropZone.addEventListener('drop', (e) => {
                const files = Array.from(e.dataTransfer.files);
                if (files.length === 1) {
                    handleFile(files[0]);
                } else if (files.length > 1) {
                    // Handle multiple files
                    handleMultipleFiles(files);
                }
            });

            dropZone.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 1) {
                    handleFile(files[0]);
                } else if (files.length > 1) {
                    handleMultipleFiles(files);
                }
            });

            // Start OCR button
            document.getElementById('startOCR').addEventListener('click', async () => {
                if (!currentFile || isProcessing) return;

                isProcessing = true;
                showElement(progressCard);
                hideElement(resultsCard);

                window.startPerformanceTracking();

                try {
                    if (Array.isArray(currentFile)) {
                        // Multiple files
                        await processBatchImages(currentFile);
                    } else if (currentFile.type === 'application/pdf') {
                        await processPDF(currentFile);
                    } else {
                        // Single image file
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            const language = document.getElementById('languageSelect').value;
                            await processOCR(e.target.result, language);
                        };
                        reader.readAsDataURL(currentFile);
                    }
                } catch (error) {
                    console.error('Erro no processamento:', error);
                    showStatus(`Erro durante o processamento: ${error.message}`, 'error');
                } finally {
                    isProcessing = false;
                }
            });

            // Text action buttons with enhanced functionality
            setupTextActionButtons();

            // Language change handler
            document.getElementById('languageSelect').addEventListener('change', (e) => {
                const isJuridical = e.target.value === 'por+jur';
                const highlightCheckbox = document.getElementById('highlightTerms');
                
                if (highlightCheckbox) {
                    highlightCheckbox.disabled = !isJuridical;
                    if (!isJuridical) {
                        highlightCheckbox.checked = false;
                    }
                }
            });
        }

        // Enhanced text action buttons
        function setupTextActionButtons() {
            // Copy with format preservation
            document.getElementById('copyText').addEventListener('click', async () => {
                const editor = document.getElementById('editorContent');
                const htmlContent = editor.innerHTML;
                const textContent = editor.textContent || editor.innerText;
                
                if (!textContent.trim()) {
                    showStatus('Nenhum texto para copiar!', 'warning');
                    return;
                }

                try {
                    // Try to copy both HTML and plain text
                    if (navigator.clipboard && navigator.clipboard.write) {
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                'text/html': new Blob([htmlContent], { type: 'text/html' }),
                                'text/plain': new Blob([textContent], { type: 'text/plain' })
                            })
                        ]);
                        showStatus('Texto copiado com formata√ß√£o preservada!', 'success');
                    } else {
                        // Fallback
                        await navigator.clipboard.writeText(textContent);
                        showStatus('Texto copiado (sem formata√ß√£o)!', 'success');
                    }
                } catch (error) {
                    // Final fallback
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = textContent;
                    document.body.appendChild(tempTextArea);
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea);
                    showStatus('Texto copiado!', 'success');
                }
            });

            // Enhanced download with metadata
            document.getElementById('downloadTxt').addEventListener('click', () => {
                const editor = document.getElementById('editorContent');
                const text = editor.textContent || editor.innerText;
                
                if (!text.trim()) {
                    showStatus('Nenhum texto para baixar!', 'warning');
                    return;
                }

                const metadata = `OCR realizado em: ${new Date().toLocaleString()}
Idioma: ${document.getElementById('languageSelect').value}
Qualidade: ${document.getElementById('qualitySelect').value}
Estat√≠sticas:
- Palavras: ${document.getElementById('wordCount').textContent}
- Caracteres: ${document.getElementById('charCount').textContent}
- Termos jur√≠dicos: ${document.getElementById('legalTermsCount').textContent}
- N√∫meros de processo: ${document.getElementById('processCount').textContent}

${'='.repeat(50)}

${text}`;

                const blob = new Blob([metadata], { type: 'text/plain; charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ocr_${new Date().toISOString().split('T')[0]}_${Date.now()}.txt`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Arquivo baixado com metadados!', 'success');
            });

            // Advanced text cleaning
            document.getElementById('cleanText').addEventListener('click', () => {
                const editor = document.getElementById('editorContent');
                let text = editor.textContent || editor.innerText;
                
                if (!text.trim()) {
                    showStatus('Nenhum texto para limpar!', 'warning');
                    return;
                }

                // Apply advanced cleaning
                text = advancedTextCorrection(text);
                editor.textContent = text;
                
                // Update statistics
                updateStatistics(text, 0, 0);
                
                showStatus('Texto limpo e corrigido com algoritmos avan√ßados!', 'success');
            });
        }

        // Handle multiple files
        function handleMultipleFiles(files) {
            const validFiles = files.filter(file => {
                try {
                    validateFile(file);
                    return true;
                } catch (error) {
                    showStatus(`Arquivo ${file.name}: ${error.message}`, 'error');
                    return false;
                }
            });

            if (validFiles.length === 0) {
                showStatus('Nenhum arquivo v√°lido selecionado!', 'error');
                return;
            }

            currentFile = validFiles;

            // Show batch info
            fileInfo.innerHTML = `
                <div class="info-block">
                    <div class="info-line">
                        <i class="fas fa-files"></i>
                        <strong>Processamento em Lote:</strong> ${validFiles.length} arquivos
                    </div>
                    <div class="info-line">
                        <i class="fas fa-weight-hanging"></i>
                        <strong>Tamanho Total:</strong> ${(validFiles.reduce((sum, f) => sum + f.size, 0) / 1024 / 1024).toFixed(2)} MB
                    </div>
                    <div class="info-line">
                        <i class="fas fa-list"></i>
                        <strong>Arquivos:</strong> ${validFiles.map(f => f.name).join(', ')}
                    </div>
                </div>
            `;

            showElement(settingsCard);
            showStatus(`${validFiles.length} arquivos carregados para processamento em lote!`, 'success');
        }

        // Initialize complete application
        function initializeCompleteApp() {
            setupEventListeners();
            initAdvancedFeatures();
            setupPerformanceMonitoring();
            setupErrorRecovery();
            
            showStatus('Sistema OCR Avan√ßado carregado! Recursos: Auto-save, Processamento em lote, Corre√ß√µes IA, Exporta√ß√£o multi-formato', 'success', 8000);
        }

        // Start application when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeCompleteApp);